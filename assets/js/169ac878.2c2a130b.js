"use strict";(globalThis.webpackChunkmy_profile_site=globalThis.webpackChunkmy_profile_site||[]).push([[9968],{28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var t=r(96540);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}},36370:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"design-patterns/behavioral/interpreter","title":"Interpreter Pattern","description":"Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.","source":"@site/docs/design-patterns/behavioral/interpreter.md","sourceDirName":"design-patterns/behavioral","slug":"/design-patterns/behavioral/interpreter","permalink":"/docs/design-patterns/behavioral/interpreter","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"Chain of Responsibility Pattern","permalink":"/docs/design-patterns/behavioral/chain-of-responsibility"},"next":{"title":"Mediator Pattern","permalink":"/docs/design-patterns/behavioral/mediator"}}');var s=r(74848),i=r(28453);const a={sidebar_position:8},l="Interpreter Pattern",o={},p=[{value:"Problem",id:"problem",level:2},{value:"Design Principles Applied",id:"design-principles-applied",level:2},{value:"UML Diagram",id:"uml-diagram",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Example 1: Arithmetic Expression Evaluator",id:"example-1-arithmetic-expression-evaluator",level:3},{value:"Step 1: Define the Context",id:"step-1-define-the-context",level:3},{value:"Step 2: Define the Abstract Expression",id:"step-2-define-the-abstract-expression",level:3},{value:"Step 3: Create Terminal Expressions",id:"step-3-create-terminal-expressions",level:3},{value:"Step 4: Create Non-Terminal Expressions",id:"step-4-create-non-terminal-expressions",level:3},{value:"Step 5: Build and Evaluate an Abstract Syntax Tree",id:"step-5-build-and-evaluate-an-abstract-syntax-tree",level:3},{value:"Example 2: Boolean Expression Evaluator",id:"example-2-boolean-expression-evaluator",level:2},{value:"Real-World Examples",id:"real-world-examples",level:2},{value:"When Not to Use Interpreter",id:"when-not-to-use-interpreter",level:2},{value:"Interpreter vs Similar Patterns",id:"interpreter-vs-similar-patterns",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"interpreter-pattern",children:"Interpreter Pattern"})}),"\n",(0,s.jsx)(n.p,{children:"Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language."}),"\n",(0,s.jsx)(n.admonition,{title:"Class Pattern",type:"note",children:(0,s.jsxs)(n.p,{children:["Interpreter is one of the four ",(0,s.jsx)(n.strong,{children:"class-scope patterns"})," in GoF. It relies on inheritance \u2014 each grammar rule maps to a subclass of ",(0,s.jsx)(n.code,{children:"AbstractExpression"}),". See ",(0,s.jsx)(n.a,{href:"/docs/design-patterns/class-and-object-patterns",children:"Class and Object Patterns"})," for details."]})}),"\n",(0,s.jsx)(n.h2,{id:"problem",children:"Problem"}),"\n",(0,s.jsx)(n.p,{children:"You have a simple language or notation that needs to be parsed and evaluated repeatedly. You want to represent each grammar rule as a class so that the grammar can be extended easily."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Common Scenarios:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Evaluating arithmetic or boolean expressions"}),"\n",(0,s.jsx)(n.li,{children:"Implementing scripting or rule engines"}),"\n",(0,s.jsx)(n.li,{children:"Parsing regular expressions or SQL-like query syntax"}),"\n",(0,s.jsx)(n.li,{children:"Configuration file interpreters"}),"\n",(0,s.jsx)(n.li,{children:"Compiler front-ends for domain-specific languages (DSLs)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"design-principles-applied",children:"Design Principles Applied"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Open/Closed Principle"})," - Add new grammar rules by adding new subclasses"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Single Responsibility"})," - Each class represents exactly one grammar rule"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Composite structure"})," - Non-terminal expressions are composed of other expressions"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"uml-diagram",children:"UML Diagram"}),"\n",(0,s.jsx)(n.mermaid,{value:'classDiagram\n    class AbstractExpression {\n        <<abstract>>\n        +interpret(Context)*\n    }\n    class TerminalExpression {\n        +interpret(Context)\n    }\n    class NonterminalExpression {\n        -AbstractExpression expressions\n        +interpret(Context)\n    }\n    class Context {\n        +lookupValue(String)\n    }\n    class Client {\n        <<actor>>\n    }\n    note for Client "Represents any code that uses the pattern, not a concrete class"\n    Client --\x3e AbstractExpression\n    Client --\x3e Context\n    AbstractExpression <|-- TerminalExpression : extends\n    AbstractExpression <|-- NonterminalExpression : extends\n    NonterminalExpression o-- AbstractExpression : expressions'}),"\n",(0,s.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"example-1-arithmetic-expression-evaluator",children:"Example 1: Arithmetic Expression Evaluator"}),"\n",(0,s.jsxs)(n.p,{children:["Evaluates expressions like ",(0,s.jsx)(n.code,{children:"5 + 3 - 2"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"step-1-define-the-context",children:"Step 1: Define the Context"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Context holds variable values for the interpreter to look up\npublic class Context {\n    private final Map<String, Integer> variables = new HashMap<>();\n\n    public void assign(String variable, int value) {\n        variables.put(variable, value);\n    }\n\n    public int lookup(String variable) {\n        return variables.getOrDefault(variable, 0);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-define-the-abstract-expression",children:"Step 2: Define the Abstract Expression"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public abstract class Expression {\n    public abstract int interpret(Context context);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-3-create-terminal-expressions",children:"Step 3: Create Terminal Expressions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Terminal: a literal number\npublic class NumberExpression extends Expression {\n    private final int number;\n\n    public NumberExpression(int number) {\n        this.number = number;\n    }\n\n    @Override\n    public int interpret(Context context) {\n        return number;\n    }\n}\n\n// Terminal: a variable name looked up in context\npublic class VariableExpression extends Expression {\n    private final String name;\n\n    public VariableExpression(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public int interpret(Context context) {\n        return context.lookup(name);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-4-create-non-terminal-expressions",children:"Step 4: Create Non-Terminal Expressions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Non-terminal: addition of two expressions\npublic class AddExpression extends Expression {\n    private final Expression left;\n    private final Expression right;\n\n    public AddExpression(Expression left, Expression right) {\n        this.left = left;\n        this.right = right;\n    }\n\n    @Override\n    public int interpret(Context context) {\n        return left.interpret(context) + right.interpret(context);\n    }\n}\n\n// Non-terminal: subtraction of two expressions\npublic class SubtractExpression extends Expression {\n    private final Expression left;\n    private final Expression right;\n\n    public SubtractExpression(Expression left, Expression right) {\n        this.left = left;\n        this.right = right;\n    }\n\n    @Override\n    public int interpret(Context context) {\n        return left.interpret(context) - right.interpret(context);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-5-build-and-evaluate-an-abstract-syntax-tree",children:"Step 5: Build and Evaluate an Abstract Syntax Tree"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'Context context = new Context();\ncontext.assign("x", 10);\ncontext.assign("y", 4);\n\n// Represents: (x + 5) - y\nExpression expression = new SubtractExpression(\n    new AddExpression(\n        new VariableExpression("x"),\n        new NumberExpression(5)\n    ),\n    new VariableExpression("y")\n);\n\nSystem.out.println(expression.interpret(context)); // (10 + 5) - 4 = 11\n'})}),"\n",(0,s.jsx)(n.h2,{id:"example-2-boolean-expression-evaluator",children:"Example 2: Boolean Expression Evaluator"}),"\n",(0,s.jsxs)(n.p,{children:["A rule engine evaluating conditions like ",(0,s.jsx)(n.code,{children:"isActive AND (hasPermission OR isAdmin)"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public abstract class BooleanExpression {\n    public abstract boolean interpret(Map<String, Boolean> context);\n}\n\n// Terminal: a named flag\npublic class VariableExp extends BooleanExpression {\n    private final String name;\n\n    public VariableExp(String name) { this.name = name; }\n\n    @Override\n    public boolean interpret(Map<String, Boolean> context) {\n        return context.getOrDefault(name, false);\n    }\n}\n\n// Non-terminal: logical AND\npublic class AndExpression extends BooleanExpression {\n    private final BooleanExpression left;\n    private final BooleanExpression right;\n\n    public AndExpression(BooleanExpression left, BooleanExpression right) {\n        this.left = left;\n        this.right = right;\n    }\n\n    @Override\n    public boolean interpret(Map<String, Boolean> context) {\n        return left.interpret(context) && right.interpret(context);\n    }\n}\n\n// Non-terminal: logical OR\npublic class OrExpression extends BooleanExpression {\n    private final BooleanExpression left;\n    private final BooleanExpression right;\n\n    public OrExpression(BooleanExpression left, BooleanExpression right) {\n        this.left = left;\n        this.right = right;\n    }\n\n    @Override\n    public boolean interpret(Map<String, Boolean> context) {\n        return left.interpret(context) || right.interpret(context);\n    }\n}\n\n// Usage: isActive AND (hasPermission OR isAdmin)\nBooleanExpression rule = new AndExpression(\n    new VariableExp("isActive"),\n    new OrExpression(\n        new VariableExp("hasPermission"),\n        new VariableExp("isAdmin")\n    )\n);\n\nMap<String, Boolean> user = Map.of(\n    "isActive", true,\n    "hasPermission", false,\n    "isAdmin", true\n);\n\nSystem.out.println(rule.interpret(user)); // true\n'})}),"\n",(0,s.jsx)(n.h2,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"java.util.regex.Pattern"})})," \u2014 compiles a regular expression grammar into an interpreter"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Spring Expression Language (SpEL)"})," \u2014 evaluates expressions like ",(0,s.jsx)(n.code,{children:"#{user.age > 18}"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SQL parsers"})," \u2014 each clause (WHERE, SELECT, JOIN) maps to an expression node"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Thymeleaf / JEXL"})," \u2014 template expression evaluators"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"when-not-to-use-interpreter",children:"When Not to Use Interpreter"}),"\n",(0,s.jsx)(n.p,{children:"The pattern works well for simple grammars. Avoid it when:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The grammar has many rules \u2014 the class count grows quickly and becomes difficult to maintain"}),"\n",(0,s.jsx)(n.li,{children:"Performance is critical \u2014 building and traversing a syntax tree has overhead"}),"\n",(0,s.jsx)(n.li,{children:"A general-purpose parser library (ANTLR, JavaCC) would be simpler to use"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"interpreter-vs-similar-patterns",children:"Interpreter vs Similar Patterns"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Pattern"}),(0,s.jsx)(n.th,{children:"Intent"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Interpreter"})}),(0,s.jsx)(n.td,{children:"Evaluates sentences in a grammar using a class-per-rule hierarchy"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Composite"})}),(0,s.jsx)(n.td,{children:"Same tree structure, but for part-whole object hierarchies rather than grammars"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Visitor"})}),(0,s.jsx)(n.td,{children:"Separates operations from the expression tree \u2014 can add new operations without changing expression classes"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Strategy"})}),(0,s.jsx)(n.td,{children:"Swaps one algorithm; Interpreter defines a language of composable operations"})]})]})]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);