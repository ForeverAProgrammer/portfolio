"use strict";(globalThis.webpackChunkmy_profile_site=globalThis.webpackChunkmy_profile_site||[]).push([[9074],{14975:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"languages/typescript/testing/vitest","title":"Vitest Testing","description":"Vitest is a blazing fast unit test framework powered by Vite. It provides a Jest-compatible API with native TypeScript support, making it the modern choice for testing TypeScript applications.","source":"@site/docs/languages/typescript/testing/vitest.md","sourceDirName":"languages/typescript/testing","slug":"/languages/typescript/testing/vitest","permalink":"/docs/languages/typescript/testing/vitest","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Jest with TypeScript","permalink":"/docs/languages/typescript/testing/jest"},"next":{"title":"Linux","permalink":"/docs/linux/"}}');var i=t(74848),a=t(28453);const r={sidebar_position:4},o="Vitest Testing",c={},l=[{value:"Why Vitest for TypeScript?",id:"why-vitest-for-typescript",level:2},{value:"Strengths",id:"strengths",level:3},{value:"Use Cases",id:"use-cases",level:3},{value:"Installation",id:"installation",level:2},{value:"Configuration",id:"configuration",level:2},{value:"vitest.config.ts",id:"vitestconfigts",level:3},{value:"With Path Aliases",id:"with-path-aliases",level:3},{value:"package.json Scripts",id:"packagejson-scripts",level:3},{value:"tsconfig.json",id:"tsconfigjson",level:3},{value:"Basic Examples",id:"basic-examples",level:2},{value:"Simple Unit Tests",id:"simple-unit-tests",level:3},{value:"Type-Safe Testing",id:"type-safe-testing",level:2},{value:"Testing with Interfaces",id:"testing-with-interfaces",level:3},{value:"Mocking with Vitest",id:"mocking-with-vitest",level:2},{value:"Type-Safe Mocks",id:"type-safe-mocks",level:3},{value:"Mocking Modules",id:"mocking-modules",level:3},{value:"Spies",id:"spies",level:3},{value:"Testing Async Code",id:"testing-async-code",level:2},{value:"Testing Type Guards and Generics",id:"testing-type-guards-and-generics",level:2},{value:"Type Guards",id:"type-guards",level:3},{value:"Generic Functions",id:"generic-functions",level:3},{value:"Snapshot Testing",id:"snapshot-testing",level:2},{value:"Benchmarking",id:"benchmarking",level:2},{value:"Code Coverage",id:"code-coverage",level:2},{value:"Coverage Configuration",id:"coverage-configuration",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use describe.concurrent for Parallel Tests",id:"1-use-describeconcurrent-for-parallel-tests",level:3},{value:"2. Use test.skip and test.only",id:"2-use-testskip-and-testonly",level:3},{value:"3. Use test.each for Parameterized Tests",id:"3-use-testeach-for-parameterized-tests",level:3},{value:"4. Custom Matchers",id:"4-custom-matchers",level:3},{value:"Common Vitest Matchers",id:"common-vitest-matchers",level:2},{value:"Migrating from Jest",id:"migrating-from-jest",level:2},{value:"Related Topics",id:"related-topics",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"vitest-testing",children:"Vitest Testing"})}),"\n",(0,i.jsx)(n.p,{children:"Vitest is a blazing fast unit test framework powered by Vite. It provides a Jest-compatible API with native TypeScript support, making it the modern choice for testing TypeScript applications."}),"\n",(0,i.jsx)(n.h2,{id:"why-vitest-for-typescript",children:"Why Vitest for TypeScript?"}),"\n",(0,i.jsx)(n.h3,{id:"strengths",children:"Strengths"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Extremely Fast"})," - 10-100x faster than Jest (Vite-powered)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Native TypeScript"})," - No transpilation needed, works out of the box"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Native ESM"})," - First-class ES modules support"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Jest Compatible"})," - Drop-in replacement with familiar API"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hot Module Replacement"})," - Instant test reruns"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Component Testing"})," - Built-in support for testing UI components"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Modern DX"})," - Beautiful UI, watch mode, parallel execution"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Modern TypeScript/JavaScript projects"}),"\n",(0,i.jsx)(n.li,{children:"Vite-based applications"}),"\n",(0,i.jsx)(n.li,{children:"Projects using ES modules"}),"\n",(0,i.jsx)(n.li,{children:"Component testing (React, Vue, Svelte)"}),"\n",(0,i.jsx)(n.li,{children:"Migration from Jest"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Install Vitest\nnpm install --save-dev vitest\n\n# Optional: Install UI for browser-based test runner\nnpm install --save-dev @vitest/ui\n\n# Optional: Install coverage tool\nnpm install --save-dev @vitest/coverage-v8\n"})}),"\n",(0,i.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsx)(n.h3,{id:"vitestconfigts",children:"vitest.config.ts"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    include: ['src/**/*.{test,spec}.ts'],\n    exclude: ['node_modules', 'dist'],\n    coverage: {\n      provider: 'v8',\n      reporter: ['text', 'json', 'html'],\n      exclude: [\n        'node_modules/',\n        'src/**/*.test.ts',\n        'src/**/*.spec.ts'\n      ]\n    },\n    // Mock functions and modules\n    mockReset: true,\n    restoreMocks: true\n  }\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"with-path-aliases",children:"With Path Aliases"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { defineConfig } from 'vitest/config';\nimport path from 'path';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node'\n  },\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, './src'),\n      '@components': path.resolve(__dirname, './src/components')\n    }\n  }\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"packagejson-scripts",children:"package.json Scripts"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": {\n    "test": "vitest",\n    "test:ui": "vitest --ui",\n    "test:run": "vitest run",\n    "test:coverage": "vitest --coverage"\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"tsconfigjson",children:"tsconfig.json"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "compilerOptions": {\n    "target": "ES2020",\n    "module": "ESNext",\n    "lib": ["ES2020"],\n    "strict": true,\n    "esModuleInterop": true,\n    "skipLibCheck": true,\n    "forceConsistentCasingInFileNames": true,\n    "types": ["vitest/globals"]\n  },\n  "include": ["src/**/*"],\n  "exclude": ["node_modules"]\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"basic-examples",children:"Basic Examples"}),"\n",(0,i.jsx)(n.h3,{id:"simple-unit-tests",children:"Simple Unit Tests"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/calculator.ts\nexport class Calculator {\n  add(a: number, b: number): number {\n    return a + b;\n  }\n\n  subtract(a: number, b: number): number {\n    return a - b;\n  }\n\n  multiply(a: number, b: number): number {\n    return a * b;\n  }\n\n  divide(a: number, b: number): number {\n    if (b === 0) {\n      throw new Error('Cannot divide by zero');\n    }\n    return a / b;\n  }\n}\n\n// src/calculator.test.ts\nimport { describe, test, expect } from 'vitest';\nimport { Calculator } from './calculator';\n\ndescribe('Calculator', () => {\n  const calc = new Calculator();\n\n  describe('add', () => {\n    test('adds two positive numbers', () => {\n      expect(calc.add(2, 3)).toBe(5);\n    });\n\n    test('adds negative numbers', () => {\n      expect(calc.add(-5, -3)).toBe(-8);\n    });\n\n    test('adds with zero', () => {\n      expect(calc.add(10, 0)).toBe(10);\n    });\n  });\n\n  describe('divide', () => {\n    test('divides two numbers', () => {\n      expect(calc.divide(10, 2)).toBe(5);\n    });\n\n    test('throws on division by zero', () => {\n      expect(() => calc.divide(10, 0)).toThrow('Cannot divide by zero');\n    });\n  });\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"type-safe-testing",children:"Type-Safe Testing"}),"\n",(0,i.jsx)(n.h3,{id:"testing-with-interfaces",children:"Testing with Interfaces"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/types.ts\nexport interface Task {\n  id: string;\n  title: string;\n  completed: boolean;\n  priority: 'low' | 'medium' | 'high';\n  createdAt: Date;\n}\n\nexport interface TaskManager {\n  addTask(task: Omit<Task, 'id' | 'createdAt'>): Task;\n  getTask(id: string): Task | undefined;\n  updateTask(id: string, updates: Partial<Task>): Task | undefined;\n  deleteTask(id: string): boolean;\n  getAllTasks(): Task[];\n}\n\n// src/taskManager.ts\nimport { Task, TaskManager } from './types';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport class InMemoryTaskManager implements TaskManager {\n  private tasks = new Map<string, Task>();\n\n  addTask(taskData: Omit<Task, 'id' | 'createdAt'>): Task {\n    const task: Task = {\n      ...taskData,\n      id: uuidv4(),\n      createdAt: new Date()\n    };\n    this.tasks.set(task.id, task);\n    return task;\n  }\n\n  getTask(id: string): Task | undefined {\n    return this.tasks.get(id);\n  }\n\n  updateTask(id: string, updates: Partial<Task>): Task | undefined {\n    const task = this.tasks.get(id);\n    if (!task) return undefined;\n\n    const updated = { ...task, ...updates };\n    this.tasks.set(id, updated);\n    return updated;\n  }\n\n  deleteTask(id: string): boolean {\n    return this.tasks.delete(id);\n  }\n\n  getAllTasks(): Task[] {\n    return Array.from(this.tasks.values());\n  }\n}\n\n// src/taskManager.test.ts\nimport { describe, test, expect, beforeEach } from 'vitest';\nimport { InMemoryTaskManager } from './taskManager';\n\ndescribe('InMemoryTaskManager', () => {\n  let manager: InMemoryTaskManager;\n\n  beforeEach(() => {\n    manager = new InMemoryTaskManager();\n  });\n\n  describe('addTask', () => {\n    test('creates task with generated ID and timestamp', () => {\n      const taskData = {\n        title: 'Write tests',\n        completed: false,\n        priority: 'high' as const\n      };\n\n      const task = manager.addTask(taskData);\n\n      expect(task).toMatchObject(taskData);\n      expect(task.id).toBeDefined();\n      expect(task.createdAt).toBeInstanceOf(Date);\n    });\n\n    test('generates unique IDs for tasks', () => {\n      const task1 = manager.addTask({\n        title: 'Task 1',\n        completed: false,\n        priority: 'low'\n      });\n      const task2 = manager.addTask({\n        title: 'Task 2',\n        completed: false,\n        priority: 'high'\n      });\n\n      expect(task1.id).not.toBe(task2.id);\n    });\n  });\n\n  describe('getTask', () => {\n    test('retrieves existing task', () => {\n      const created = manager.addTask({\n        title: 'Test Task',\n        completed: false,\n        priority: 'medium'\n      });\n\n      const retrieved = manager.getTask(created.id);\n\n      expect(retrieved).toEqual(created);\n    });\n\n    test('returns undefined for non-existent task', () => {\n      const result = manager.getTask('non-existent-id');\n      expect(result).toBeUndefined();\n    });\n  });\n\n  describe('updateTask', () => {\n    test('updates task fields', () => {\n      const task = manager.addTask({\n        title: 'Original Title',\n        completed: false,\n        priority: 'low'\n      });\n\n      const updated = manager.updateTask(task.id, {\n        title: 'Updated Title',\n        completed: true\n      });\n\n      expect(updated).toBeDefined();\n      expect(updated!.title).toBe('Updated Title');\n      expect(updated!.completed).toBe(true);\n      expect(updated!.priority).toBe('low'); // unchanged\n    });\n\n    test('returns undefined for non-existent task', () => {\n      const result = manager.updateTask('non-existent', { completed: true });\n      expect(result).toBeUndefined();\n    });\n  });\n\n  describe('deleteTask', () => {\n    test('deletes existing task', () => {\n      const task = manager.addTask({\n        title: 'To Delete',\n        completed: false,\n        priority: 'low'\n      });\n\n      const deleted = manager.deleteTask(task.id);\n      expect(deleted).toBe(true);\n\n      const retrieved = manager.getTask(task.id);\n      expect(retrieved).toBeUndefined();\n    });\n\n    test('returns false for non-existent task', () => {\n      const result = manager.deleteTask('non-existent');\n      expect(result).toBe(false);\n    });\n  });\n\n  describe('getAllTasks', () => {\n    test('returns all tasks', () => {\n      manager.addTask({ title: 'Task 1', completed: false, priority: 'low' });\n      manager.addTask({ title: 'Task 2', completed: true, priority: 'high' });\n\n      const tasks = manager.getAllTasks();\n\n      expect(tasks).toHaveLength(2);\n    });\n\n    test('returns empty array when no tasks', () => {\n      const tasks = manager.getAllTasks();\n      expect(tasks).toHaveLength(0);\n    });\n  });\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"mocking-with-vitest",children:"Mocking with Vitest"}),"\n",(0,i.jsx)(n.h3,{id:"type-safe-mocks",children:"Type-Safe Mocks"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/services/emailService.ts\nexport interface EmailService {\n  sendEmail(to: string, subject: string, body: string): Promise<void>;\n}\n\nexport class SMTPEmailService implements EmailService {\n  async sendEmail(to: string, subject: string, body: string): Promise<void> {\n    // SMTP implementation\n    console.log(`Sending email to ${to}`);\n  }\n}\n\n// src/services/notificationService.ts\nimport { EmailService } from './emailService';\n\nexport class NotificationService {\n  constructor(private emailService: EmailService) {}\n\n  async notifyUser(email: string, message: string): Promise<void> {\n    await this.emailService.sendEmail(\n      email,\n      'Notification',\n      message\n    );\n  }\n}\n\n// src/services/notificationService.test.ts\nimport { describe, test, expect, vi, beforeEach } from 'vitest';\nimport { NotificationService } from './notificationService';\nimport { EmailService } from './emailService';\n\ndescribe('NotificationService', () => {\n  let mockEmailService: EmailService;\n  let notificationService: NotificationService;\n\n  beforeEach(() => {\n    mockEmailService = {\n      sendEmail: vi.fn()\n    };\n    notificationService = new NotificationService(mockEmailService);\n  });\n\n  test('sends notification email', async () => {\n    await notificationService.notifyUser(\n      'user@example.com',\n      'Hello, World!'\n    );\n\n    expect(mockEmailService.sendEmail).toHaveBeenCalledWith(\n      'user@example.com',\n      'Notification',\n      'Hello, World!'\n    );\n    expect(mockEmailService.sendEmail).toHaveBeenCalledTimes(1);\n  });\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"mocking-modules",children:"Mocking Modules"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/api/userApi.ts\nexport async function fetchUserById(id: number) {\n  const response = await fetch(`https://api.example.com/users/${id}`);\n  if (!response.ok) {\n    throw new Error(`Failed to fetch user: ${response.status}`);\n  }\n  return response.json();\n}\n\n// src/api/userApi.test.ts\nimport { describe, test, expect, vi, beforeEach } from 'vitest';\nimport { fetchUserById } from './userApi';\n\n// Mock global fetch\nglobal.fetch = vi.fn();\n\ndescribe('fetchUserById', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  test('fetches user successfully', async () => {\n    const mockUser = { id: 1, name: 'John Doe' };\n\n    (fetch as any).mockResolvedValue({\n      ok: true,\n      json: async () => mockUser\n    });\n\n    const result = await fetchUserById(1);\n\n    expect(result).toEqual(mockUser);\n    expect(fetch).toHaveBeenCalledWith('https://api.example.com/users/1');\n  });\n\n  test('throws error on failed request', async () => {\n    (fetch as any).mockResolvedValue({\n      ok: false,\n      status: 404\n    });\n\n    await expect(fetchUserById(1)).rejects.toThrow('Failed to fetch user: 404');\n  });\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"spies",children:"Spies"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { describe, test, expect, vi } from 'vitest';\n\ndescribe('Spy examples', () => {\n  test('spies on object method', () => {\n    const obj = {\n      getValue: () => 42\n    };\n\n    const spy = vi.spyOn(obj, 'getValue');\n\n    obj.getValue();\n    obj.getValue();\n\n    expect(spy).toHaveBeenCalledTimes(2);\n    expect(spy).toHaveReturnedWith(42);\n\n    spy.mockRestore();\n  });\n\n  test('spies and mocks return value', () => {\n    const obj = {\n      getValue: () => 42\n    };\n\n    const spy = vi.spyOn(obj, 'getValue').mockReturnValue(100);\n\n    expect(obj.getValue()).toBe(100);\n    expect(spy).toHaveBeenCalled();\n  });\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-async-code",children:"Testing Async Code"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/async.ts\nexport async function fetchData(url: string): Promise<any> {\n  const response = await fetch(url);\n  return response.json();\n}\n\nexport async function processData(id: number): Promise<string> {\n  const data = await fetchData(`https://api.example.com/data/${id}`);\n  return `Processed: ${data.value}`;\n}\n\n// src/async.test.ts\nimport { describe, test, expect, vi } from 'vitest';\nimport { fetchData, processData } from './async';\n\nglobal.fetch = vi.fn();\n\ndescribe('Async operations', () => {\n  test('fetchData retrieves data', async () => {\n    const mockData = { id: 1, value: 'test' };\n\n    (fetch as any).mockResolvedValue({\n      ok: true,\n      json: async () => mockData\n    });\n\n    const result = await fetchData('https://api.example.com/data/1');\n\n    expect(result).toEqual(mockData);\n  });\n\n  test('processData transforms data', async () => {\n    const mockData = { value: 'hello' };\n\n    (fetch as any).mockResolvedValue({\n      ok: true,\n      json: async () => mockData\n    });\n\n    const result = await processData(1);\n\n    expect(result).toBe('Processed: hello');\n  });\n\n  test('handles rejection', async () => {\n    (fetch as any).mockRejectedValue(new Error('Network error'));\n\n    await expect(fetchData('https://api.example.com/data/1'))\n      .rejects\n      .toThrow('Network error');\n  });\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-type-guards-and-generics",children:"Testing Type Guards and Generics"}),"\n",(0,i.jsx)(n.h3,{id:"type-guards",children:"Type Guards"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/validation.ts\nexport interface ValidationResult {\n  valid: boolean;\n  errors?: string[];\n}\n\nexport function isValidationResult(obj: unknown): obj is ValidationResult {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    'valid' in obj &&\n    typeof (obj as any).valid === 'boolean'\n  );\n}\n\n// src/validation.test.ts\nimport { describe, test, expect } from 'vitest';\nimport { isValidationResult, ValidationResult } from './validation';\n\ndescribe('isValidationResult', () => {\n  test('identifies valid ValidationResult', () => {\n    const result: ValidationResult = { valid: true };\n    expect(isValidationResult(result)).toBe(true);\n  });\n\n  test('identifies ValidationResult with errors', () => {\n    const result: ValidationResult = {\n      valid: false,\n      errors: ['Error 1']\n    };\n    expect(isValidationResult(result)).toBe(true);\n  });\n\n  test('rejects invalid objects', () => {\n    expect(isValidationResult(null)).toBe(false);\n    expect(isValidationResult({})).toBe(false);\n    expect(isValidationResult({ valid: 'yes' })).toBe(false);\n  });\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"generic-functions",children:"Generic Functions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/utils.ts\nexport function groupBy<T, K extends string | number>(\n  items: T[],\n  keyFn: (item: T) => K\n): Record<K, T[]> {\n  return items.reduce((acc, item) => {\n    const key = keyFn(item);\n    if (!acc[key]) {\n      acc[key] = [];\n    }\n    acc[key].push(item);\n    return acc;\n  }, {} as Record<K, T[]>);\n}\n\n// src/utils.test.ts\nimport { describe, test, expect } from 'vitest';\nimport { groupBy } from './utils';\n\ndescribe('groupBy', () => {\n  test('groups objects by key', () => {\n    const items = [\n      { id: 1, category: 'A' },\n      { id: 2, category: 'B' },\n      { id: 3, category: 'A' }\n    ];\n\n    const result = groupBy(items, (item) => item.category);\n\n    expect(result).toEqual({\n      A: [{ id: 1, category: 'A' }, { id: 3, category: 'A' }],\n      B: [{ id: 2, category: 'B' }]\n    });\n  });\n\n  test('groups numbers by predicate', () => {\n    const numbers = [1, 2, 3, 4, 5, 6];\n\n    const result = groupBy(numbers, (n) => (n % 2 === 0 ? 'even' : 'odd'));\n\n    expect(result).toEqual({\n      odd: [1, 3, 5],\n      even: [2, 4, 6]\n    });\n  });\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"snapshot-testing",children:"Snapshot Testing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/formatter.ts\nexport interface Report {\n  title: string;\n  date: Date;\n  items: string[];\n  total: number;\n}\n\nexport function formatReport(report: Report): string {\n  return `\n=== ${report.title} ===\nDate: ${report.date.toISOString()}\nItems: ${report.items.length}\nTotal: $${report.total.toFixed(2)}\n\nDetails:\n${report.items.map((item, i) => `  ${i + 1}. ${item}`).join('\\n')}\n  `.trim();\n}\n\n// src/formatter.test.ts\nimport { describe, test, expect } from 'vitest';\nimport { formatReport, Report } from './formatter';\n\ndescribe('formatReport', () => {\n  test('formats report correctly', () => {\n    const report: Report = {\n      title: 'Monthly Report',\n      date: new Date('2024-01-01T00:00:00.000Z'),\n      items: ['Item 1', 'Item 2', 'Item 3'],\n      total: 299.99\n    };\n\n    expect(formatReport(report)).toMatchSnapshot();\n  });\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"benchmarking",children:"Benchmarking"}),"\n",(0,i.jsx)(n.p,{children:"Vitest includes built-in benchmarking:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// src/performance.bench.ts\nimport { bench, describe } from 'vitest';\n\ndescribe('Array operations', () => {\n  const array = Array.from({ length: 10000 }, (_, i) => i);\n\n  bench('for loop', () => {\n    let sum = 0;\n    for (let i = 0; i < array.length; i++) {\n      sum += array[i];\n    }\n  });\n\n  bench('forEach', () => {\n    let sum = 0;\n    array.forEach((n) => (sum += n));\n  });\n\n  bench('reduce', () => {\n    array.reduce((sum, n) => sum + n, 0);\n  });\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:"Run benchmarks:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"vitest bench\n"})}),"\n",(0,i.jsx)(n.h2,{id:"code-coverage",children:"Code Coverage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Run tests with coverage\nnpm test -- --coverage\n\n# Watch mode with coverage\nnpm test -- --coverage --watch\n\n# Coverage with specific reporter\nnpm test -- --coverage --reporter=html\n"})}),"\n",(0,i.jsx)(n.h3,{id:"coverage-configuration",children:"Coverage Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// vitest.config.ts\nexport default defineConfig({\n  test: {\n    coverage: {\n      provider: 'v8',\n      reporter: ['text', 'json', 'html'],\n      exclude: [\n        'node_modules/',\n        'src/**/*.test.ts',\n        'src/**/*.spec.ts',\n        'src/**/*.d.ts'\n      ],\n      thresholds: {\n        lines: 80,\n        functions: 80,\n        branches: 80,\n        statements: 80\n      }\n    }\n  }\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"1-use-describeconcurrent-for-parallel-tests",children:"1. Use describe.concurrent for Parallel Tests"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { describe, test } from 'vitest';\n\ndescribe.concurrent('Parallel tests', () => {\n  test('test 1', async () => {\n    // Runs in parallel with other tests\n  });\n\n  test('test 2', async () => {\n    // Runs in parallel\n  });\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-use-testskip-and-testonly",children:"2. Use test.skip and test.only"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"test.skip('skip this test', () => {\n  // This test won't run\n});\n\ntest.only('only run this test', () => {\n  // Only this test will run\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-use-testeach-for-parameterized-tests",children:"3. Use test.each for Parameterized Tests"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { test, expect } from 'vitest';\n\ntest.each([\n  [1, 2, 3],\n  [2, 3, 5],\n  [10, 20, 30]\n])('adds %i + %i to equal %i', (a, b, expected) => {\n  expect(a + b).toBe(expected);\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-custom-matchers",children:"4. Custom Matchers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { expect } from 'vitest';\n\nexpect.extend({\n  toBeWithinRange(received: number, min: number, max: number) {\n    const pass = received >= min && received <= max;\n    return {\n      pass,\n      message: () =>\n        pass\n          ? `expected ${received} not to be within range ${min} - ${max}`\n          : `expected ${received} to be within range ${min} - ${max}`\n    };\n  }\n});\n\ntest('custom matcher', () => {\n  expect(15).toBeWithinRange(10, 20);\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"common-vitest-matchers",children:"Common Vitest Matchers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Same as Jest - Vitest is API compatible\nexpect(value).toBe(5);\nexpect(obj).toEqual({ a: 1 });\nexpect(value).toBeTruthy();\nexpect(arr).toContain(item);\nexpect(fn).toThrow();\nawait expect(promise).resolves.toBe(value);\n\n// Mock assertions\nexpect(mockFn).toHaveBeenCalled();\nexpect(mockFn).toHaveBeenCalledWith(arg1, arg2);\nexpect(mockFn).toHaveBeenCalledTimes(2);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"migrating-from-jest",children:"Migrating from Jest"}),"\n",(0,i.jsx)(n.p,{children:"Vitest is mostly compatible with Jest. Key differences:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Configuration"}),": Use ",(0,i.jsx)(n.code,{children:"vitest.config.ts"})," instead of ",(0,i.jsx)(n.code,{children:"jest.config.js"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Imports"}),": Can import from ",(0,i.jsx)(n.code,{children:"vitest"})," or use globals"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mocking"}),": Use ",(0,i.jsx)(n.code,{children:"vi"})," instead of ",(0,i.jsx)(n.code,{children:"jest"})]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Jest\nimport { jest } from '@jest/globals';\nconst mock = jest.fn();\n\n// Vitest\nimport { vi } from 'vitest';\nconst mock = vi.fn();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/languages/typescript/testing/",children:"TypeScript Testing Overview"})," - Testing framework comparison"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/languages/typescript/testing/jest",children:"Jest Testing"})," - Jest with TypeScript"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/languages/typescript/testing/mocha-chai",children:"Mocha + Chai Testing"})," - BDD/TDD style testing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/languages/typescript/testing/cypress",children:"Cypress E2E Testing"})," - End-to-end testing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/languages/typescript/fundamentals/",children:"TypeScript Fundamentals"})," - Core TypeScript concepts"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(96540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);