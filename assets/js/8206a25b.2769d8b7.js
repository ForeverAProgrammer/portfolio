"use strict";(globalThis.webpackChunkmy_profile_site=globalThis.webpackChunkmy_profile_site||[]).push([[5363],{28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>l});var s=n(96540);const r={},i=s.createContext(r);function a(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:t},e.children)}},85468:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"design-patterns/class-and-object-patterns","title":"Class and Object Patterns","description":"The GoF book organizes patterns by two dimensions: purpose (creational, structural, behavioral) and scope (class or object). Understanding scope helps you choose between patterns and explains why some patterns feel similar but behave differently.","source":"@site/docs/design-patterns/class-and-object-patterns.md","sourceDirName":"design-patterns","slug":"/design-patterns/class-and-object-patterns","permalink":"/docs/design-patterns/class-and-object-patterns","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Visitor Pattern","permalink":"/docs/design-patterns/behavioral/visitor"},"next":{"title":"Structural Patterns","permalink":"/docs/design-patterns/structural/"}}');var r=n(74848),i=n(28453);const a={sidebar_position:2},l="Class and Object Patterns",d={},c=[{value:"Scope: Class vs Object",id:"scope-class-vs-object",level:2},{value:"Class Patterns",id:"class-patterns",level:3},{value:"Object Patterns",id:"object-patterns",level:3},{value:"Class vs Object: Side-by-Side Comparison",id:"class-vs-object-side-by-side-comparison",level:2},{value:"Template Method vs Strategy: Class vs Object",id:"template-method-vs-strategy-class-vs-object",level:2},{value:"Factory Method vs Abstract Factory: Class vs Object",id:"factory-method-vs-abstract-factory-class-vs-object",level:2},{value:"When Scope Matters in Practice",id:"when-scope-matters-in-practice",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function o(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"class-and-object-patterns",children:"Class and Object Patterns"})}),"\n",(0,r.jsxs)(t.p,{children:["The GoF book organizes patterns by two dimensions: ",(0,r.jsx)(t.strong,{children:"purpose"})," (creational, structural, behavioral) and ",(0,r.jsx)(t.strong,{children:"scope"})," (class or object). Understanding scope helps you choose between patterns and explains why some patterns feel similar but behave differently."]}),"\n",(0,r.jsx)(t.h2,{id:"scope-class-vs-object",children:"Scope: Class vs Object"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Scope"}),(0,r.jsx)(t.th,{children:"Relationship type"}),(0,r.jsx)(t.th,{children:"Set at"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Class"})}),(0,r.jsx)(t.td,{children:"Inheritance (static)"}),(0,r.jsx)(t.td,{children:"Compile time"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Object"})}),(0,r.jsx)(t.td,{children:"Composition / delegation (dynamic)"}),(0,r.jsx)(t.td,{children:"Runtime"})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"class-patterns",children:"Class Patterns"}),"\n",(0,r.jsxs)(t.p,{children:["Class patterns use ",(0,r.jsx)(t.strong,{children:"inheritance"})," as their primary mechanism. The relationship between the base class and subclasses is fixed at compile time \u2014 you can't swap in a different behavior without changing the class hierarchy."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Pattern"}),(0,r.jsx)(t.th,{children:"Category"}),(0,r.jsx)(t.th,{children:"What the subclass does"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Factory Method"})}),(0,r.jsx)(t.td,{children:"Creational"}),(0,r.jsx)(t.td,{children:"Decides which concrete object to instantiate"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.strong,{children:"Adapter"})," ",(0,r.jsx)(t.em,{children:"(class variant)"})]}),(0,r.jsx)(t.td,{children:"Structural"}),(0,r.jsx)(t.td,{children:"Adapts an incompatible interface via multiple inheritance"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Template Method"})}),(0,r.jsx)(t.td,{children:"Behavioral"}),(0,r.jsx)(t.td,{children:"Fills in specific steps of an algorithm defined by the parent"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Interpreter"})}),(0,r.jsx)(t.td,{children:"Behavioral"}),(0,r.jsx)(t.td,{children:"Implements interpretation of one grammar rule"})]})]})]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Example \u2014 Template Method (class pattern):"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'// The algorithm skeleton lives in the abstract parent class\npublic abstract class DataExporter {\n\n    // Template method: fixed structure, defined once\n    public final void export(String destination) {\n        fetchData();        // concrete \u2014 same for all\n        formatData();       // abstract \u2014 subclass fills this in\n        writeToFile(destination); // concrete \u2014 same for all\n    }\n\n    protected abstract void formatData();\n\n    private void fetchData() { System.out.println("Fetching data..."); }\n    private void writeToFile(String dest) { System.out.println("Writing to " + dest); }\n}\n\n// The relationship is fixed: CsvExporter always formats as CSV\npublic class CsvExporter extends DataExporter {\n    @Override\n    protected void formatData() {\n        System.out.println("Formatting as CSV");\n    }\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["The formatting behavior can't be changed at runtime \u2014 ",(0,r.jsx)(t.code,{children:"CsvExporter"})," will always be a CSV exporter."]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h3,{id:"object-patterns",children:"Object Patterns"}),"\n",(0,r.jsxs)(t.p,{children:["Object patterns use ",(0,r.jsx)(t.strong,{children:"composition and delegation"}),". Objects hold references to other objects and forward work to them. You can swap those references at runtime, making object patterns far more flexible than class patterns."]}),"\n",(0,r.jsx)(t.p,{children:"All other GoF patterns fall into this category:"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Pattern"}),(0,r.jsx)(t.th,{children:"Category"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Singleton"}),(0,r.jsx)(t.td,{children:"Creational"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Abstract Factory"}),(0,r.jsx)(t.td,{children:"Creational"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Builder"}),(0,r.jsx)(t.td,{children:"Creational"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Prototype"}),(0,r.jsx)(t.td,{children:"Creational"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{children:["Adapter ",(0,r.jsx)(t.em,{children:"(object variant)"})]}),(0,r.jsx)(t.td,{children:"Structural"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Bridge"}),(0,r.jsx)(t.td,{children:"Structural"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Composite"}),(0,r.jsx)(t.td,{children:"Structural"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Decorator"}),(0,r.jsx)(t.td,{children:"Structural"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Facade"}),(0,r.jsx)(t.td,{children:"Structural"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Flyweight"}),(0,r.jsx)(t.td,{children:"Structural"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Proxy"}),(0,r.jsx)(t.td,{children:"Structural"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Chain of Responsibility"}),(0,r.jsx)(t.td,{children:"Behavioral"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Command"}),(0,r.jsx)(t.td,{children:"Behavioral"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Iterator"}),(0,r.jsx)(t.td,{children:"Behavioral"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Mediator"}),(0,r.jsx)(t.td,{children:"Behavioral"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Memento"}),(0,r.jsx)(t.td,{children:"Behavioral"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Observer"}),(0,r.jsx)(t.td,{children:"Behavioral"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"State"}),(0,r.jsx)(t.td,{children:"Behavioral"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Strategy"}),(0,r.jsx)(t.td,{children:"Behavioral"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Visitor"}),(0,r.jsx)(t.td,{children:"Behavioral"})]})]})]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Example \u2014 Composite (object pattern):"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'// The "object" relationship: a component holds references to other components\npublic interface FileSystemComponent {\n    void display(String indent);\n}\n\npublic class File implements FileSystemComponent {\n    private String name;\n\n    public File(String name) { this.name = name; }\n\n    @Override\n    public void display(String indent) {\n        System.out.println(indent + name);\n    }\n}\n\npublic class Folder implements FileSystemComponent {\n    private String name;\n    // Holds a list of child components \u2014 set and changed at runtime\n    private List<FileSystemComponent> children = new ArrayList<>();\n\n    public Folder(String name) { this.name = name; }\n\n    public void add(FileSystemComponent component) {\n        children.add(component);\n    }\n\n    @Override\n    public void display(String indent) {\n        System.out.println(indent + name + "/");\n        for (FileSystemComponent child : children) {\n            child.display(indent + "  ");\n        }\n    }\n}\n\n// Usage \u2014 tree is assembled at runtime, not fixed at compile time\nFolder root = new Folder("root");\nroot.add(new File("readme.txt"));\nFolder src = new Folder("src");\nsrc.add(new File("Main.java"));\nroot.add(src);\nroot.display("");\n'})}),"\n",(0,r.jsx)(t.p,{children:"The tree structure is built at runtime. You can add, remove, or reorganize nodes without touching any class definitions."}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"class-vs-object-side-by-side-comparison",children:"Class vs Object: Side-by-Side Comparison"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Aspect"}),(0,r.jsx)(t.th,{children:"Class Pattern"}),(0,r.jsx)(t.th,{children:"Object Pattern"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Mechanism"})}),(0,r.jsx)(t.td,{children:"Inheritance"}),(0,r.jsx)(t.td,{children:"Composition / delegation"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Flexibility"})}),(0,r.jsx)(t.td,{children:"Lower \u2014 fixed at compile time"}),(0,r.jsx)(t.td,{children:"Higher \u2014 configurable at runtime"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Coupling"})}),(0,r.jsx)(t.td,{children:"Tighter \u2014 subclass depends on parent"}),(0,r.jsx)(t.td,{children:"Looser \u2014 objects interact through interfaces"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Number of classes"})}),(0,r.jsx)(t.td,{children:"Fewer (subclassing reuses code)"}),(0,r.jsx)(t.td,{children:"Potentially more (one per role)"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Behavior change"})}),(0,r.jsx)(t.td,{children:"Requires a new subclass"}),(0,r.jsx)(t.td,{children:"Swap the referenced object"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Examples"})}),(0,r.jsx)(t.td,{children:"Template Method, Factory Method"}),(0,r.jsx)(t.td,{children:"Strategy, Composite, Observer"})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"template-method-vs-strategy-class-vs-object",children:"Template Method vs Strategy: Class vs Object"}),"\n",(0,r.jsx)(t.p,{children:"These two patterns solve the same problem \u2014 varying part of an algorithm \u2014 but from opposite ends of the class/object axis."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"// CLASS PATTERN \u2014 Template Method (inheritance)\n// The variation is baked in at compile time via subclassing\npublic abstract class Sorter {\n    public final void sort(int[] data) {\n        prepare(data);\n        doSort(data);     // subclass decides how to sort\n    }\n    protected abstract void doSort(int[] data);\n}\n\npublic class QuickSorter extends Sorter {\n    @Override\n    protected void doSort(int[] data) { /* quicksort implementation */ }\n}\n\n\n// OBJECT PATTERN \u2014 Strategy (composition)\n// The variation is plugged in at runtime via a reference\npublic class Sorter {\n    private SortStrategy strategy;  // can be changed at any time\n\n    public Sorter(SortStrategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public void setStrategy(SortStrategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public void sort(int[] data) {\n        strategy.sort(data);\n    }\n}\n\npublic interface SortStrategy {\n    void sort(int[] data);\n}\n\npublic class QuickSort implements SortStrategy {\n    @Override\n    public void sort(int[] data) { /* quicksort implementation */ }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Use Template Method when"})," the algorithm's structure is stable and you control the class hierarchy.\n",(0,r.jsx)(t.strong,{children:"Use Strategy when"})," you need to switch algorithms at runtime or keep the context class decoupled from sorting logic."]}),"\n",(0,r.jsx)(t.h2,{id:"factory-method-vs-abstract-factory-class-vs-object",children:"Factory Method vs Abstract Factory: Class vs Object"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{}),(0,r.jsx)(t.th,{children:"Factory Method (class)"}),(0,r.jsx)(t.th,{children:"Abstract Factory (object)"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Creates"})}),(0,r.jsx)(t.td,{children:"One product"}),(0,r.jsx)(t.td,{children:"Families of related products"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"How"})}),(0,r.jsx)(t.td,{children:"Subclassing"}),(0,r.jsx)(t.td,{children:"Object composition"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.strong,{children:"Example"})}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.code,{children:"createButton()"})," in subclass"]}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.code,{children:"GUIFactory"})," held as a field"]})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"when-scope-matters-in-practice",children:"When Scope Matters in Practice"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Prefer class patterns when:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"The variation is known at compile time and won't change"}),"\n",(0,r.jsx)(t.li,{children:"You want the compiler to enforce correct behavior"}),"\n",(0,r.jsx)(t.li,{children:"Simplicity matters more than runtime flexibility"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Prefer object patterns when:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Behavior needs to vary at runtime (user configuration, feature flags)"}),"\n",(0,r.jsxs)(t.li,{children:["You want to follow ",(0,r.jsx)(t.em,{children:"Favor Composition Over Inheritance"})]}),"\n",(0,r.jsx)(t.li,{children:"You need to unit test components independently with mocks"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["GoF patterns have two axes: ",(0,r.jsx)(t.strong,{children:"purpose"})," (creational/structural/behavioral) and ",(0,r.jsx)(t.strong,{children:"scope"})," (class/object)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Class patterns"})," use inheritance \u2014 relationships are fixed at compile time"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Object patterns"})," use composition \u2014 relationships are configured at runtime"]}),"\n",(0,r.jsx)(t.li,{children:"The four class patterns are: Factory Method, Adapter (class), Template Method, Interpreter"}),"\n",(0,r.jsxs)(t.li,{children:["Object patterns are generally preferred in modern OOP because they support the ",(0,r.jsx)(t.em,{children:"Favor Composition Over Inheritance"})," principle"]}),"\n",(0,r.jsx)(t.li,{children:"Template Method (class) and Strategy (object) are the clearest illustration of the trade-off between the two scopes"}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Understanding scope helps you choose the right pattern \u2014 and understand why your design feels rigid or flexible."})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}}}]);