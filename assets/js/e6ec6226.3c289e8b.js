"use strict";(globalThis.webpackChunkmy_profile_site=globalThis.webpackChunkmy_profile_site||[]).push([[14],{2687:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"languages/typescript/testing/mocha-chai","title":"Mocha + Chai Testing","description":"Mocha is a flexible JavaScript test framework, and Chai is a BDD/TDD assertion library. Together they provide a powerful, highly configurable testing solution for TypeScript applications.","source":"@site/docs/languages/typescript/testing/mocha-chai.md","sourceDirName":"languages/typescript/testing","slug":"/languages/typescript/testing/mocha-chai","permalink":"/portfolio/docs/languages/typescript/testing/mocha-chai","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Testing","permalink":"/portfolio/docs/languages/typescript/testing/"},"next":{"title":"Cypress E2E Testing","permalink":"/portfolio/docs/languages/typescript/testing/cypress"}}');var r=t(4848),i=t(8453);const a={sidebar_position:1},o="Mocha + Chai Testing",c={},l=[{value:"Why Mocha + Chai for TypeScript?",id:"why-mocha--chai-for-typescript",level:2},{value:"Strengths",id:"strengths",level:3},{value:"Use Cases",id:"use-cases",level:3},{value:"Installation",id:"installation",level:2},{value:"Configuration",id:"configuration",level:2},{value:"package.json",id:"packagejson",level:3},{value:".mocharc.json",id:"mocharcjson",level:3},{value:"tsconfig.json",id:"tsconfigjson",level:3},{value:"Basic Examples",id:"basic-examples",level:2},{value:"Simple Unit Test",id:"simple-unit-test",level:3},{value:"Assertion Styles",id:"assertion-styles",level:3},{value:"Type-Safe Testing",id:"type-safe-testing",level:2},{value:"Testing Interfaces",id:"testing-interfaces",level:3},{value:"Async Testing",id:"async-testing",level:2},{value:"Testing Promises",id:"testing-promises",level:3},{value:"Using chai-as-promised",id:"using-chai-as-promised",level:3},{value:"Testing Type Guards",id:"testing-type-guards",level:2},{value:"Testing Generics",id:"testing-generics",level:2},{value:"Code Coverage with NYC",id:"code-coverage-with-nyc",level:2},{value:"Installation",id:"installation-1",level:3},{value:"Configuration (.nycrc.json)",id:"configuration-nycrcjson",level:3},{value:"package.json",id:"packagejson-1",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Organize Tests by Feature",id:"1-organize-tests-by-feature",level:3},{value:"2. Use Type-Safe Test Data",id:"2-use-type-safe-test-data",level:3},{value:"3. Test Error Conditions",id:"3-test-error-conditions",level:3},{value:"4. Use Hooks for Setup/Teardown",id:"4-use-hooks-for-setupteardown",level:3},{value:"Common Chai Assertions",id:"common-chai-assertions",level:2},{value:"Related Topics",id:"related-topics",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"mocha--chai-testing",children:"Mocha + Chai Testing"})}),"\n",(0,r.jsx)(n.p,{children:"Mocha is a flexible JavaScript test framework, and Chai is a BDD/TDD assertion library. Together they provide a powerful, highly configurable testing solution for TypeScript applications."}),"\n",(0,r.jsx)(n.h2,{id:"why-mocha--chai-for-typescript",children:"Why Mocha + Chai for TypeScript?"}),"\n",(0,r.jsx)(n.h3,{id:"strengths",children:"Strengths"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flexibility"})," - Choose your own assertion library, mocking tools"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multiple Styles"})," - BDD (should/expect) and TDD (assert) styles"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Browser Support"})," - Runs in both Node.js and browsers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Async Support"})," - First-class promise and async/await support"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rich Ecosystem"})," - Extensive plugin ecosystem"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TypeScript Support"})," - Type definitions available"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Projects requiring custom test configurations"}),"\n",(0,r.jsx)(n.li,{children:"Teams preferring BDD-style assertions"}),"\n",(0,r.jsx)(n.li,{children:"Browser and Node.js testing"}),"\n",(0,r.jsx)(n.li,{children:"Migrating from older test frameworks"}),"\n",(0,r.jsx)(n.li,{children:"Projects needing specific reporters"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Install Mocha, Chai, and TypeScript support\nnpm install --save-dev mocha chai @types/mocha @types/chai\n\n# Install ts-node to run TypeScript tests\nnpm install --save-dev ts-node\n\n# Optional: Chai plugins\nnpm install --save-dev @types/chai-as-promised  # For promise assertions\n"})}),"\n",(0,r.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsx)(n.h3,{id:"packagejson",children:"package.json"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": {\n    "test": "mocha --require ts-node/register \'tests/**/*.test.ts\'",\n    "test:watch": "mocha --require ts-node/register --watch --watch-files \'src/**/*.ts,tests/**/*.test.ts\' \'tests/**/*.test.ts\'",\n    "test:coverage": "nyc mocha --require ts-node/register \'tests/**/*.test.ts\'"\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"mocharcjson",children:".mocharc.json"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "require": ["ts-node/register"],\n  "extensions": ["ts"],\n  "spec": ["tests/**/*.test.ts"],\n  "watch-files": ["src/**/*.ts", "tests/**/*.test.ts"],\n  "timeout": 3000\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"tsconfigjson",children:"tsconfig.json"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "compilerOptions": {\n    "target": "ES2020",\n    "module": "commonjs",\n    "strict": true,\n    "esModuleInterop": true,\n    "skipLibCheck": true,\n    "forceConsistentCasingInFileNames": true,\n    "types": ["mocha", "chai", "node"]\n  },\n  "include": ["src/**/*", "tests/**/*"],\n  "exclude": ["node_modules"]\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"basic-examples",children:"Basic Examples"}),"\n",(0,r.jsx)(n.h3,{id:"simple-unit-test",children:"Simple Unit Test"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/math.ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\n// tests/math.test.ts\nimport { expect } from 'chai';\nimport { add, multiply } from '../src/math';\n\ndescribe('Math utilities', () => {\n  describe('add()', () => {\n    it('should add two positive numbers', () => {\n      expect(add(2, 3)).to.equal(5);\n    });\n\n    it('should handle negative numbers', () => {\n      expect(add(-5, 3)).to.equal(-2);\n    });\n\n    it('should handle zero', () => {\n      expect(add(0, 5)).to.equal(5);\n    });\n  });\n\n  describe('multiply()', () => {\n    it('should multiply two numbers', () => {\n      expect(multiply(3, 4)).to.equal(12);\n    });\n\n    it('should handle zero', () => {\n      expect(multiply(5, 0)).to.equal(0);\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"assertion-styles",children:"Assertion Styles"}),"\n",(0,r.jsx)(n.p,{children:"Chai supports multiple assertion styles:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { expect, assert, should } from 'chai';\n\ndescribe('Assertion styles', () => {\n  // Expect style (BDD) - most popular\n  it('expect style', () => {\n    const name = 'TypeScript';\n    expect(name).to.be.a('string');\n    expect(name).to.have.length(10);\n    expect(name).to.include('Script');\n  });\n\n  // Assert style (TDD)\n  it('assert style', () => {\n    const value = 42;\n    assert.typeOf(value, 'number');\n    assert.equal(value, 42);\n    assert.isAbove(value, 40);\n  });\n\n  // Should style (BDD) - requires initialization\n  it('should style', () => {\n    should();\n    const arr = [1, 2, 3];\n    arr.should.have.length(3);\n    arr.should.include(2);\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"type-safe-testing",children:"Type-Safe Testing"}),"\n",(0,r.jsx)(n.h3,{id:"testing-interfaces",children:"Testing Interfaces"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/types.ts\nexport interface User {\n  id: number;\n  name: string;\n  email: string;\n  role: 'admin' | 'user';\n}\n\nexport interface UserService {\n  getUser(id: number): User | undefined;\n  createUser(data: Omit<User, 'id'>): User;\n  updateUser(id: number, data: Partial<User>): User | undefined;\n  deleteUser(id: number): boolean;\n}\n\n// src/userService.ts\nexport class UserServiceImpl implements UserService {\n  private users: Map<number, User> = new Map();\n  private nextId = 1;\n\n  getUser(id: number): User | undefined {\n    return this.users.get(id);\n  }\n\n  createUser(data: Omit<User, 'id'>): User {\n    const user: User = { ...data, id: this.nextId++ };\n    this.users.set(user.id, user);\n    return user;\n  }\n\n  updateUser(id: number, data: Partial<User>): User | undefined {\n    const user = this.users.get(id);\n    if (!user) return undefined;\n\n    const updated = { ...user, ...data };\n    this.users.set(id, updated);\n    return updated;\n  }\n\n  deleteUser(id: number): boolean {\n    return this.users.delete(id);\n  }\n}\n\n// tests/userService.test.ts\nimport { expect } from 'chai';\nimport { UserServiceImpl } from '../src/userService';\nimport { User } from '../src/types';\n\ndescribe('UserService', () => {\n  let service: UserServiceImpl;\n\n  beforeEach(() => {\n    service = new UserServiceImpl();\n  });\n\n  describe('createUser()', () => {\n    it('should create a user with generated ID', () => {\n      const userData = {\n        name: 'John Doe',\n        email: 'john@example.com',\n        role: 'user' as const\n      };\n\n      const user = service.createUser(userData);\n\n      expect(user).to.have.property('id');\n      expect(user.id).to.be.a('number');\n      expect(user.name).to.equal('John Doe');\n      expect(user.email).to.equal('john@example.com');\n      expect(user.role).to.equal('user');\n    });\n\n    it('should assign unique IDs', () => {\n      const user1 = service.createUser({\n        name: 'User 1',\n        email: 'user1@example.com',\n        role: 'user'\n      });\n      const user2 = service.createUser({\n        name: 'User 2',\n        email: 'user2@example.com',\n        role: 'admin'\n      });\n\n      expect(user1.id).to.not.equal(user2.id);\n    });\n  });\n\n  describe('getUser()', () => {\n    it('should retrieve existing user', () => {\n      const created = service.createUser({\n        name: 'Test User',\n        email: 'test@example.com',\n        role: 'user'\n      });\n\n      const retrieved = service.getUser(created.id);\n\n      expect(retrieved).to.deep.equal(created);\n    });\n\n    it('should return undefined for non-existent user', () => {\n      const user = service.getUser(999);\n      expect(user).to.be.undefined;\n    });\n  });\n\n  describe('updateUser()', () => {\n    it('should update user fields', () => {\n      const created = service.createUser({\n        name: 'Original Name',\n        email: 'original@example.com',\n        role: 'user'\n      });\n\n      const updated = service.updateUser(created.id, {\n        name: 'Updated Name'\n      });\n\n      expect(updated).to.not.be.undefined;\n      expect(updated!.name).to.equal('Updated Name');\n      expect(updated!.email).to.equal('original@example.com'); // unchanged\n    });\n\n    it('should return undefined for non-existent user', () => {\n      const result = service.updateUser(999, { name: 'Test' });\n      expect(result).to.be.undefined;\n    });\n  });\n\n  describe('deleteUser()', () => {\n    it('should delete existing user', () => {\n      const user = service.createUser({\n        name: 'To Delete',\n        email: 'delete@example.com',\n        role: 'user'\n      });\n\n      const deleted = service.deleteUser(user.id);\n      expect(deleted).to.be.true;\n\n      const retrieved = service.getUser(user.id);\n      expect(retrieved).to.be.undefined;\n    });\n\n    it('should return false for non-existent user', () => {\n      const result = service.deleteUser(999);\n      expect(result).to.be.false;\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"async-testing",children:"Async Testing"}),"\n",(0,r.jsx)(n.h3,{id:"testing-promises",children:"Testing Promises"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/api.ts\nexport interface Post {\n  id: number;\n  title: string;\n  body: string;\n}\n\nexport class ApiClient {\n  async fetchPost(id: number): Promise<Post> {\n    const response = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return response.json();\n  }\n\n  async createPost(data: Omit<Post, 'id'>): Promise<Post> {\n    const response = await fetch('https://jsonplaceholder.typicode.com/posts', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(data)\n    });\n    return response.json();\n  }\n}\n\n// tests/api.test.ts\nimport { expect } from 'chai';\nimport { ApiClient } from '../src/api';\n\ndescribe('ApiClient', () => {\n  let client: ApiClient;\n\n  beforeEach(() => {\n    client = new ApiClient();\n  });\n\n  describe('fetchPost()', () => {\n    it('should fetch a post by ID', async () => {\n      const post = await client.fetchPost(1);\n\n      expect(post).to.be.an('object');\n      expect(post).to.have.property('id', 1);\n      expect(post).to.have.property('title');\n      expect(post).to.have.property('body');\n    });\n\n    it('should throw error for invalid ID', async () => {\n      try {\n        await client.fetchPost(99999);\n        expect.fail('Should have thrown error');\n      } catch (error) {\n        expect(error).to.be.instanceOf(Error);\n      }\n    });\n  });\n\n  describe('createPost()', () => {\n    it('should create a new post', async () => {\n      const newPost = {\n        title: 'Test Post',\n        body: 'This is a test post'\n      };\n\n      const created = await client.createPost(newPost);\n\n      expect(created).to.have.property('id');\n      expect(created.title).to.equal(newPost.title);\n      expect(created.body).to.equal(newPost.body);\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"using-chai-as-promised",children:"Using chai-as-promised"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import chai from 'chai';\nimport chaiAsPromised from 'chai-as-promised';\n\nchai.use(chaiAsPromised);\nconst { expect } = chai;\n\ndescribe('Promise assertions', () => {\n  it('should eventually resolve', () => {\n    const promise = Promise.resolve('success');\n    return expect(promise).to.eventually.equal('success');\n  });\n\n  it('should be rejected', () => {\n    const promise = Promise.reject(new Error('Failed'));\n    return expect(promise).to.be.rejectedWith(Error, 'Failed');\n  });\n\n  it('should fulfill with expected value', async () => {\n    const getData = async (): Promise<string> => {\n      return 'data';\n    };\n\n    await expect(getData()).to.eventually.equal('data');\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"testing-type-guards",children:"Testing Type Guards"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/guards.ts\nexport interface Circle {\n  kind: 'circle';\n  radius: number;\n}\n\nexport interface Square {\n  kind: 'square';\n  sideLength: number;\n}\n\nexport type Shape = Circle | Square;\n\nexport function isCircle(shape: Shape): shape is Circle {\n  return shape.kind === 'circle';\n}\n\nexport function isSquare(shape: Shape): shape is Square {\n  return shape.kind === 'square';\n}\n\nexport function getArea(shape: Shape): number {\n  if (isCircle(shape)) {\n    return Math.PI * shape.radius ** 2;\n  } else {\n    return shape.sideLength ** 2;\n  }\n}\n\n// tests/guards.test.ts\nimport { expect } from 'chai';\nimport { isCircle, isSquare, getArea, Circle, Square } from '../src/guards';\n\ndescribe('Shape type guards', () => {\n  const circle: Circle = { kind: 'circle', radius: 5 };\n  const square: Square = { kind: 'square', sideLength: 4 };\n\n  describe('isCircle()', () => {\n    it('should identify circles', () => {\n      expect(isCircle(circle)).to.be.true;\n    });\n\n    it('should reject squares', () => {\n      expect(isCircle(square)).to.be.false;\n    });\n  });\n\n  describe('isSquare()', () => {\n    it('should identify squares', () => {\n      expect(isSquare(square)).to.be.true;\n    });\n\n    it('should reject circles', () => {\n      expect(isSquare(circle)).to.be.false;\n    });\n  });\n\n  describe('getArea()', () => {\n    it('should calculate circle area', () => {\n      const area = getArea(circle);\n      expect(area).to.be.closeTo(78.54, 0.01);\n    });\n\n    it('should calculate square area', () => {\n      const area = getArea(square);\n      expect(area).to.equal(16);\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"testing-generics",children:"Testing Generics"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/queue.ts\nexport class Queue<T> {\n  private items: T[] = [];\n\n  enqueue(item: T): void {\n    this.items.push(item);\n  }\n\n  dequeue(): T | undefined {\n    return this.items.shift();\n  }\n\n  peek(): T | undefined {\n    return this.items[0];\n  }\n\n  size(): number {\n    return this.items.length;\n  }\n\n  isEmpty(): boolean {\n    return this.items.length === 0;\n  }\n}\n\n// tests/queue.test.ts\nimport { expect } from 'chai';\nimport { Queue } from '../src/queue';\n\ndescribe('Queue<T>', () => {\n  describe('with numbers', () => {\n    let queue: Queue<number>;\n\n    beforeEach(() => {\n      queue = new Queue<number>();\n    });\n\n    it('should enqueue and dequeue numbers', () => {\n      queue.enqueue(1);\n      queue.enqueue(2);\n      queue.enqueue(3);\n\n      expect(queue.dequeue()).to.equal(1);\n      expect(queue.dequeue()).to.equal(2);\n      expect(queue.size()).to.equal(1);\n    });\n\n    it('should peek without removing', () => {\n      queue.enqueue(42);\n\n      expect(queue.peek()).to.equal(42);\n      expect(queue.size()).to.equal(1);\n    });\n  });\n\n  describe('with strings', () => {\n    let queue: Queue<string>;\n\n    beforeEach(() => {\n      queue = new Queue<string>();\n    });\n\n    it('should work with string types', () => {\n      queue.enqueue('first');\n      queue.enqueue('second');\n\n      expect(queue.dequeue()).to.equal('first');\n      expect(queue.size()).to.equal(1);\n    });\n  });\n\n  describe('with objects', () => {\n    interface Task {\n      id: number;\n      name: string;\n    }\n\n    let queue: Queue<Task>;\n\n    beforeEach(() => {\n      queue = new Queue<Task>();\n    });\n\n    it('should handle complex objects', () => {\n      const task1: Task = { id: 1, name: 'Task 1' };\n      const task2: Task = { id: 2, name: 'Task 2' };\n\n      queue.enqueue(task1);\n      queue.enqueue(task2);\n\n      expect(queue.dequeue()).to.deep.equal(task1);\n      expect(queue.peek()).to.deep.equal(task2);\n    });\n  });\n\n  describe('edge cases', () => {\n    it('should return undefined when dequeuing empty queue', () => {\n      const queue = new Queue<number>();\n      expect(queue.dequeue()).to.be.undefined;\n    });\n\n    it('should correctly report empty status', () => {\n      const queue = new Queue<number>();\n      expect(queue.isEmpty()).to.be.true;\n\n      queue.enqueue(1);\n      expect(queue.isEmpty()).to.be.false;\n\n      queue.dequeue();\n      expect(queue.isEmpty()).to.be.true;\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"code-coverage-with-nyc",children:"Code Coverage with NYC"}),"\n",(0,r.jsx)(n.h3,{id:"installation-1",children:"Installation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install --save-dev nyc\n"})}),"\n",(0,r.jsx)(n.h3,{id:"configuration-nycrcjson",children:"Configuration (.nycrc.json)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "extends": "@istanbuljs/nyc-config-typescript",\n  "all": true,\n  "check-coverage": true,\n  "branches": 80,\n  "lines": 80,\n  "functions": 80,\n  "statements": 80,\n  "reporter": ["text", "html", "lcov"],\n  "include": ["src/**/*.ts"],\n  "exclude": ["**/*.d.ts", "**/*.test.ts", "tests/**"]\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"packagejson-1",children:"package.json"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": {\n    "test:coverage": "nyc mocha",\n    "coverage:report": "nyc report --reporter=html"\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-organize-tests-by-feature",children:"1. Organize Tests by Feature"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"describe('UserService', () => {\n  describe('Authentication', () => {\n    it('should authenticate valid credentials');\n    it('should reject invalid credentials');\n  });\n\n  describe('Registration', () => {\n    it('should register new users');\n    it('should prevent duplicate emails');\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-use-type-safe-test-data",children:"2. Use Type-Safe Test Data"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface TestUser {\n  name: string;\n  email: string;\n  role: 'admin' | 'user';\n}\n\nfunction createTestUser(overrides?: Partial<TestUser>): TestUser {\n  return {\n    name: 'Test User',\n    email: 'test@example.com',\n    role: 'user',\n    ...overrides\n  };\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-test-error-conditions",children:"3. Test Error Conditions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"it('should throw error for invalid input', () => {\n  expect(() => validateEmail('invalid')).to.throw(Error, 'Invalid email');\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-use-hooks-for-setupteardown",children:"4. Use Hooks for Setup/Teardown"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"describe('Database tests', () => {\n  before(() => {\n    // Run once before all tests\n  });\n\n  beforeEach(() => {\n    // Run before each test\n  });\n\n  afterEach(() => {\n    // Run after each test\n  });\n\n  after(() => {\n    // Run once after all tests\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"common-chai-assertions",children:"Common Chai Assertions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Equality\nexpect(value).to.equal(42);\nexpect(obj).to.deep.equal({ a: 1 });\nexpect(value).to.eql(expected); // Deep equality\n\n// Type checking\nexpect(value).to.be.a('string');\nexpect(value).to.be.an('array');\nexpect(value).to.be.instanceof(MyClass);\n\n// Truthiness\nexpect(value).to.be.true;\nexpect(value).to.be.false;\nexpect(value).to.be.null;\nexpect(value).to.be.undefined;\nexpect(value).to.exist;\n\n// Comparisons\nexpect(value).to.be.above(10);\nexpect(value).to.be.below(100);\nexpect(value).to.be.within(1, 10);\n\n// Strings\nexpect(str).to.include('substring');\nexpect(str).to.match(/regex/);\nexpect(str).to.have.length(5);\n\n// Arrays\nexpect(arr).to.have.length(3);\nexpect(arr).to.include(2);\nexpect(arr).to.have.members([1, 2, 3]);\nexpect(arr).to.be.empty;\n\n// Objects\nexpect(obj).to.have.property('name');\nexpect(obj).to.have.property('age', 25);\nexpect(obj).to.have.keys(['name', 'age']);\nexpect(obj).to.deep.include({ name: 'John' });\n\n// Functions\nexpect(fn).to.throw();\nexpect(fn).to.throw(Error);\nexpect(fn).to.throw(Error, 'message');\n\n// Promises\nexpect(promise).to.eventually.equal('value');\nexpect(promise).to.be.fulfilled;\nexpect(promise).to.be.rejected;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/portfolio/docs/languages/typescript/testing/",children:"TypeScript Testing Overview"})," - Testing framework comparison"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/portfolio/docs/languages/typescript/testing/cypress",children:"Cypress E2E Testing"})," - End-to-end testing with Cypress"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../fundamentals/",children:"TypeScript Fundamentals"})," - Core TypeScript concepts"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);