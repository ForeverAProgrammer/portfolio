"use strict";(globalThis.webpackChunkmy_profile_site=globalThis.webpackChunkmy_profile_site||[]).push([[2951],{28453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>l});var t=a(96540);const r={},i=t.createContext(r);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(i.Provider,{value:n},e.children)}},49187:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"design-patterns/structural/adapter","title":"Adapter Pattern","description":"Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn\'t otherwise because of incompatible interfaces.","source":"@site/docs/design-patterns/structural/adapter.md","sourceDirName":"design-patterns/structural","slug":"/design-patterns/structural/adapter","permalink":"/docs/design-patterns/structural/adapter","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Decorator Pattern","permalink":"/docs/design-patterns/structural/decorator"},"next":{"title":"Facade Pattern","permalink":"/docs/design-patterns/structural/facade"}}');var r=a(74848),i=a(28453);const s={sidebar_position:2},l="Adapter Pattern",d={},c=[{value:"Problem",id:"problem",level:2},{value:"Design Principles Applied",id:"design-principles-applied",level:2},{value:"UML Diagram",id:"uml-diagram",level:2},{value:"Object Adapter (using Composition)",id:"object-adapter-using-composition",level:3},{value:"Class Adapter (using Inheritance)",id:"class-adapter-using-inheritance",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Example: Media Player",id:"example-media-player",level:3},{value:"Step 1: Target Interface",id:"step-1-target-interface",level:3},{value:"Step 2: Adaptee Classes (Incompatible Interfaces)",id:"step-2-adaptee-classes-incompatible-interfaces",level:3},{value:"Step 3: Adapter Class",id:"step-3-adapter-class",level:3},{value:"Step 4: Concrete Target",id:"step-4-concrete-target",level:3},{value:"Step 5: Client Code",id:"step-5-client-code",level:3},{value:"Real-World Examples",id:"real-world-examples",level:2},{value:"Example 2: Temperature Sensor Adapter",id:"example-2-temperature-sensor-adapter",level:3},{value:"Example 3: Database Adapter",id:"example-3-database-adapter",level:3},{value:"Java API Examples",id:"java-api-examples",level:2},{value:"InputStreamReader",id:"inputstreamreader",level:3},{value:"Arrays.asList()",id:"arraysaslist",level:3},{value:"Collections Framework",id:"collections-framework",level:3},{value:"Object Adapter vs Class Adapter",id:"object-adapter-vs-class-adapter",level:2},{value:"Object Adapter (Composition)",id:"object-adapter-composition",level:3},{value:"Class Adapter (Inheritance)",id:"class-adapter-inheritance",level:3},{value:"Two-Way Adapter",id:"two-way-adapter",level:2},{value:"Advantages",id:"advantages",level:2},{value:"Disadvantages",id:"disadvantages",level:2},{value:"When to Use",id:"when-to-use",level:2},{value:"Related Patterns",id:"related-patterns",level:2},{value:"Adapter vs Bridge vs Decorator",id:"adapter-vs-bridge-vs-decorator",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"adapter-pattern",children:"Adapter Pattern"})}),"\n",(0,r.jsx)(n.p,{children:"Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces."}),"\n",(0,r.jsx)(n.h2,{id:"problem",children:"Problem"}),"\n",(0,r.jsx)(n.p,{children:"You want to use an existing class, but its interface doesn't match the one you need. Or you want to create a reusable class that cooperates with classes that don't have compatible interfaces."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Common Scenarios:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Integrating third-party libraries with incompatible interfaces"}),"\n",(0,r.jsx)(n.li,{children:"Working with legacy code that can't be modified"}),"\n",(0,r.jsx)(n.li,{children:"Using multiple data sources with different APIs"}),"\n",(0,r.jsx)(n.li,{children:"Adapting objects for collections that expect specific interfaces"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"design-principles-applied",children:"Design Principles Applied"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Program to an interface, not implementation"})," - Adapter implements target interface"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Favor composition over inheritance"})," - Object adapter uses composition"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Open/Closed Principle"})," - Extend without modifying existing code"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"uml-diagram",children:"UML Diagram"}),"\n",(0,r.jsx)(n.h3,{id:"object-adapter-using-composition",children:"Object Adapter (using Composition)"}),"\n",(0,r.jsx)(n.mermaid,{value:'classDiagram\n    class Client {\n        <<actor>>\n    }\n    class Target {\n        <<interface>>\n        +request()\n    }\n    class Adapter {\n        -Adaptee adaptee\n        +request()\n    }\n    class Adaptee {\n        +specificRequest()\n    }\n    note for Client "Represents any code that uses the pattern, not a concrete class"\n    Client --\x3e Target\n    Target <|.. Adapter : implements\n    Adapter --\x3e Adaptee : adaptee\n'}),"\n",(0,r.jsx)(n.h3,{id:"class-adapter-using-inheritance",children:"Class Adapter (using Inheritance)"}),"\n",(0,r.jsx)(n.mermaid,{value:'classDiagram\n    class Client {\n        <<actor>>\n    }\n    class Target {\n        <<interface>>\n        +request()\n    }\n    class Adapter {\n        +request()\n    }\n    class Adaptee {\n        +specificRequest()\n    }\n    note for Client "Represents any code that uses the pattern, not a concrete class"\n    Client --\x3e Target\n    Target <|.. Adapter : implements\n    Adapter <|-- Adaptee : extends\n'}),"\n",(0,r.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"example-media-player",children:"Example: Media Player"}),"\n",(0,r.jsx)(n.p,{children:"Let's adapt different media formats to work with a common media player interface."}),"\n",(0,r.jsx)(n.h3,{id:"step-1-target-interface",children:"Step 1: Target Interface"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Target interface - what client expects\npublic interface MediaPlayer {\n    void play(String audioType, String fileName);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-2-adaptee-classes-incompatible-interfaces",children:"Step 2: Adaptee Classes (Incompatible Interfaces)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Advanced media player interface (incompatible with MediaPlayer)\npublic interface AdvancedMediaPlayer {\n    void playVlc(String fileName);\n    void playMp4(String fileName);\n}\n\n// Concrete adaptee - VLC Player\npublic class VlcPlayer implements AdvancedMediaPlayer {\n    @Override\n    public void playVlc(String fileName) {\n        System.out.println("Playing VLC file: " + fileName);\n    }\n\n    @Override\n    public void playMp4(String fileName) {\n        // Do nothing - VLC player doesn\'t support MP4\n    }\n}\n\n// Concrete adaptee - MP4 Player\npublic class Mp4Player implements AdvancedMediaPlayer {\n    @Override\n    public void playVlc(String fileName) {\n        // Do nothing - MP4 player doesn\'t support VLC\n    }\n\n    @Override\n    public void playMp4(String fileName) {\n        System.out.println("Playing MP4 file: " + fileName);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"step-3-adapter-class",children:"Step 3: Adapter Class"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Adapter - adapts AdvancedMediaPlayer to MediaPlayer interface\npublic class MediaAdapter implements MediaPlayer {\n    private AdvancedMediaPlayer advancedMusicPlayer;\n\n    public MediaAdapter(String audioType) {\n        if (audioType.equalsIgnoreCase("vlc")) {\n            advancedMusicPlayer = new VlcPlayer();\n        } else if (audioType.equalsIgnoreCase("mp4")) {\n            advancedMusicPlayer = new Mp4Player();\n        }\n    }\n\n    @Override\n    public void play(String audioType, String fileName) {\n        if (audioType.equalsIgnoreCase("vlc")) {\n            advancedMusicPlayer.playVlc(fileName);\n        } else if (audioType.equalsIgnoreCase("mp4")) {\n            advancedMusicPlayer.playMp4(fileName);\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"step-4-concrete-target",children:"Step 4: Concrete Target"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Concrete implementation of MediaPlayer\npublic class AudioPlayer implements MediaPlayer {\n    private MediaAdapter mediaAdapter;\n\n    @Override\n    public void play(String audioType, String fileName) {\n        // Built-in support for mp3\n        if (audioType.equalsIgnoreCase("mp3")) {\n            System.out.println("Playing MP3 file: " + fileName);\n        }\n        // Use adapter for other formats\n        else if (audioType.equalsIgnoreCase("vlc") ||\n                 audioType.equalsIgnoreCase("mp4")) {\n            mediaAdapter = new MediaAdapter(audioType);\n            mediaAdapter.play(audioType, fileName);\n        } else {\n            System.out.println("Invalid media type: " + audioType);\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"step-5-client-code",children:"Step 5: Client Code"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class AdapterDemo {\n    public static void main(String[] args) {\n        AudioPlayer audioPlayer = new AudioPlayer();\n\n        audioPlayer.play("mp3", "song.mp3");\n        audioPlayer.play("mp4", "video.mp4");\n        audioPlayer.play("vlc", "movie.vlc");\n        audioPlayer.play("avi", "movie.avi");\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Output:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Playing MP3 file: song.mp3\nPlaying MP4 file: video.mp4\nPlaying VLC file: movie.vlc\nInvalid media type: avi\n"})}),"\n",(0,r.jsx)(n.h2,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,r.jsx)(n.h3,{id:"example-2-temperature-sensor-adapter",children:"Example 2: Temperature Sensor Adapter"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Target interface - Celsius temperature\npublic interface CelsiusTemperature {\n    double getTemperatureInCelsius();\n}\n\n// Adaptee - Fahrenheit sensor (legacy system)\npublic class FahrenheitSensor {\n    public double getTemperatureInFahrenheit() {\n        // Simulate reading from sensor\n        return 98.6; // Normal body temperature\n    }\n}\n\n// Adapter - converts Fahrenheit to Celsius\npublic class TemperatureAdapter implements CelsiusTemperature {\n    private FahrenheitSensor fahrenheitSensor;\n\n    public TemperatureAdapter(FahrenheitSensor sensor) {\n        this.fahrenheitSensor = sensor;\n    }\n\n    @Override\n    public double getTemperatureInCelsius() {\n        double fahrenheit = fahrenheitSensor.getTemperatureInFahrenheit();\n        return (fahrenheit - 32) * 5 / 9;\n    }\n}\n\n// Client\npublic class TemperatureMonitor {\n    private CelsiusTemperature sensor;\n\n    public TemperatureMonitor(CelsiusTemperature sensor) {\n        this.sensor = sensor;\n    }\n\n    public void displayTemperature() {\n        System.out.printf("Temperature: %.1f\xb0C%n",\n            sensor.getTemperatureInCelsius());\n    }\n\n    public static void main(String[] args) {\n        // Using legacy Fahrenheit sensor with Celsius monitor\n        FahrenheitSensor fahrenheitSensor = new FahrenheitSensor();\n        CelsiusTemperature adapter = new TemperatureAdapter(fahrenheitSensor);\n        TemperatureMonitor monitor = new TemperatureMonitor(adapter);\n\n        monitor.displayTemperature();\n        // Output: Temperature: 37.0\xb0C\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"example-3-database-adapter",children:"Example 3: Database Adapter"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Target interface\npublic interface DatabaseConnection {\n    void connect(String connectionString);\n    ResultSet executeQuery(String query);\n    void disconnect();\n}\n\n// Adaptee - Legacy database API\npublic class LegacyDatabase {\n    public void openConnection(String host, int port, String database) {\n        System.out.println("Legacy connection opened: " +\n            host + ":" + port + "/" + database);\n    }\n\n    public List<Map<String, Object>> runQuery(String sql) {\n        System.out.println("Executing legacy query: " + sql);\n        return new ArrayList<>();\n    }\n\n    public void closeConnection() {\n        System.out.println("Legacy connection closed");\n    }\n}\n\n// Adapter\npublic class DatabaseAdapter implements DatabaseConnection {\n    private LegacyDatabase legacyDb;\n\n    public DatabaseAdapter() {\n        this.legacyDb = new LegacyDatabase();\n    }\n\n    @Override\n    public void connect(String connectionString) {\n        // Parse modern connection string: "host:port/database"\n        String[] parts = connectionString.split("[:/]");\n        String host = parts[0];\n        int port = Integer.parseInt(parts[1]);\n        String database = parts[2];\n\n        legacyDb.openConnection(host, port, database);\n    }\n\n    @Override\n    public ResultSet executeQuery(String query) {\n        List<Map<String, Object>> legacyResult = legacyDb.runQuery(query);\n        // Convert legacy result to ResultSet\n        return convertToResultSet(legacyResult);\n    }\n\n    @Override\n    public void disconnect() {\n        legacyDb.closeConnection();\n    }\n\n    private ResultSet convertToResultSet(List<Map<String, Object>> data) {\n        // Implementation of conversion logic\n        return null; // Simplified for example\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"java-api-examples",children:"Java API Examples"}),"\n",(0,r.jsx)(n.h3,{id:"inputstreamreader",children:"InputStreamReader"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Adapts InputStream (byte stream) to Reader (character stream)\nInputStream inputStream = new FileInputStream("file.txt");\nReader reader = new InputStreamReader(inputStream);\n\n// InputStreamReader is an adapter that bridges byte streams to character streams\n'})}),"\n",(0,r.jsx)(n.h3,{id:"arraysaslist",children:"Arrays.asList()"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Adapts array to List interface\nString[] array = {"a", "b", "c"};\nList<String> list = Arrays.asList(array);\n\n// Arrays.asList() adapts array to List interface\n'})}),"\n",(0,r.jsx)(n.h3,{id:"collections-framework",children:"Collections Framework"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Enumeration to Iterator adapter\nEnumeration<String> enumeration = vector.elements();\nIterator<String> iterator = Collections.list(enumeration).iterator();\n"})}),"\n",(0,r.jsx)(n.h2,{id:"object-adapter-vs-class-adapter",children:"Object Adapter vs Class Adapter"}),"\n",(0,r.jsx)(n.h3,{id:"object-adapter-composition",children:"Object Adapter (Composition)"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Advantages:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"More flexible - can adapt many adaptees through one adapter"}),"\n",(0,r.jsx)(n.li,{children:"Works when adaptee is final or from third-party library"}),"\n",(0,r.jsx)(n.li,{children:'Follows "favor composition over inheritance"'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Disadvantages:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Requires more code to delegate calls"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public class ObjectAdapter implements Target {\n    private Adaptee adaptee; // Composition\n\n    public ObjectAdapter(Adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n\n    public void request() {\n        adaptee.specificRequest();\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"class-adapter-inheritance",children:"Class Adapter (Inheritance)"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Advantages:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Less code - no need to delegate"}),"\n",(0,r.jsx)(n.li,{children:"Can override adaptee's behavior"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Disadvantages:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Less flexible - can only adapt one class"}),"\n",(0,r.jsx)(n.li,{children:"Doesn't work with final classes"}),"\n",(0,r.jsx)(n.li,{children:"Java doesn't support multiple inheritance"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public class ClassAdapter extends Adaptee implements Target {\n    public void request() {\n        specificRequest(); // Inherited method\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"two-way-adapter",children:"Two-Way Adapter"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Adapter that works both ways\npublic class TwoWayAdapter implements Target, Adaptee {\n    private Target target;\n    private Adaptee adaptee;\n\n    public TwoWayAdapter(Target target) {\n        this.target = target;\n    }\n\n    public TwoWayAdapter(Adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n\n    // Target interface implementation\n    public void request() {\n        if (adaptee != null) {\n            adaptee.specificRequest();\n        }\n    }\n\n    // Adaptee interface implementation\n    public void specificRequest() {\n        if (target != null) {\n            target.request();\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"advantages",children:"Advantages"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compatibility"})," - Makes incompatible interfaces work together"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reusability"})," - Reuse existing classes with incompatible interfaces"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flexibility"})," - Easily integrate third-party libraries"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Maintainability"})," - Changes to adaptee don't affect client"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single Responsibility"})," - Separates interface conversion from business logic"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"disadvantages",children:"Disadvantages"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Complexity"})," - Adds extra layer of abstraction"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"})," - Slight overhead from delegation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Code Overhead"})," - Additional classes increase codebase size"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Use Adapter Pattern When:"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"You want to use an existing class with incompatible interface"}),"\n",(0,r.jsx)(n.li,{children:"You need to integrate legacy code with new systems"}),"\n",(0,r.jsx)(n.li,{children:"You want to create reusable classes that work with unrelated classes"}),"\n",(0,r.jsx)(n.li,{children:"You need to use several existing subclasses with missing functionality"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Don't Use Adapter Pattern When:"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"You can modify the source code directly"}),"\n",(0,r.jsx)(n.li,{children:"The interfaces are already compatible"}),"\n",(0,r.jsx)(n.li,{children:"Creating adapter adds unnecessary complexity"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"related-patterns",children:"Related Patterns"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bridge"})," - Separates interface from implementation (designed upfront)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Decorator"})," - Adds responsibilities without changing interface"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Proxy"})," - Provides same interface with controlled access"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Facade"})," - Simplifies interface (doesn't adapt existing interface)"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"adapter-vs-bridge-vs-decorator",children:"Adapter vs Bridge vs Decorator"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Pattern"}),(0,r.jsx)(n.th,{children:"Intent"}),(0,r.jsx)(n.th,{children:"When Designed"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Adapter"})}),(0,r.jsx)(n.td,{children:"Make incompatible interfaces compatible"}),(0,r.jsx)(n.td,{children:"After systems are designed"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Bridge"})}),(0,r.jsx)(n.td,{children:"Separate abstraction from implementation"}),(0,r.jsx)(n.td,{children:"Before system is designed"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Decorator"})}),(0,r.jsx)(n.td,{children:"Add responsibilities dynamically"}),(0,r.jsx)(n.td,{children:"Either"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Converts one interface to another"}),"\n",(0,r.jsx)(n.li,{children:"Allows incompatible classes to work together"}),"\n",(0,r.jsx)(n.li,{children:"Wraps existing class with new interface"}),"\n",(0,r.jsx)(n.li,{children:"Object adapter uses composition (preferred)"}),"\n",(0,r.jsx)(n.li,{children:"Class adapter uses inheritance (when possible)"}),"\n",(0,r.jsx)(n.li,{children:"Common in integrating legacy systems"}),"\n",(0,r.jsx)(n.li,{children:"Client remains unaware of adapter"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"The Adapter Pattern makes classes work together that couldn't otherwise because of incompatible interfaces!"})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}}}]);