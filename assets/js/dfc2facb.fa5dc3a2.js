"use strict";(globalThis.webpackChunkmy_profile_site=globalThis.webpackChunkmy_profile_site||[]).push([[5470],{1150:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var s=i(5874),t=i(4848),l=i(8453);const r={slug:"gitlab-cicd-pipelines",title:"Building CI/CD Pipelines with GitLab",authors:["kristina-haynes"],tags:["cicd","gitlab","devops","automation"]},a="Building CI/CD Pipelines with GitLab",o={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:2},{value:"Pipeline Architecture",id:"pipeline-architecture",level:2},{value:"Stage 1: Build",id:"stage-1-build",level:2},{value:"Stage 2: Test",id:"stage-2-test",level:2},{value:"Stage 3: Deploy",id:"stage-3-deploy",level:2},{value:"Pipeline Design Patterns",id:"pipeline-design-patterns",level:2},{value:"Global Cache Configuration",id:"global-cache-configuration",level:3},{value:"Cache Policy Strategy",id:"cache-policy-strategy",level:3},{value:"Artifact Management",id:"artifact-management",level:3},{value:"CI/CD Best Practices Demonstrated",id:"cicd-best-practices-demonstrated",level:2},{value:"Pipeline Variables",id:"pipeline-variables",level:2},{value:"Monitoring Pipeline Performance",id:"monitoring-pipeline-performance",level:2},{value:"Extending the Pipeline",id:"extending-the-pipeline",level:2},{value:"Adding Security Scanning",id:"adding-security-scanning",level:3},{value:"Multi-Environment Deployments",id:"multi-environment-deployments",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Resources",id:"resources",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"A comprehensive guide to designing and implementing automated deployment pipelines using GitLab CI/CD, featuring a real-world example with caching, artifacts, and GitLab Pages deployment."}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"GitLab CI/CD is a powerful tool for automating your software development lifecycle. In this guide, I'll walk through a production-ready CI/CD pipeline I built that demonstrates key concepts like Docker build images, caching strategies, artifact management, and automated deployments."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example Project"}),": ",(0,t.jsx)(n.a,{href:"https://gitlab.com/kristina-portfolio/gitlab-cicd-pipeline-example",children:"gitlab-cicd-pipeline-example"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Live Demo"}),": ",(0,t.jsx)(n.a,{href:"https://gitlab-cicd-pipeline-example-c2a1fe.gitlab.io/",children:"https://gitlab-cicd-pipeline-example-c2a1fe.gitlab.io/"})]}),"\n",(0,t.jsx)(n.h2,{id:"pipeline-architecture",children:"Pipeline Architecture"}),"\n",(0,t.jsx)(n.p,{children:"The pipeline follows a classic three-stage design:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Build \u2192 Test \u2192 Deploy\n"})}),"\n",(0,t.jsx)(n.p,{children:"Each stage has a specific purpose and builds upon the previous stage's outputs. Let's explore how each stage works."}),"\n",(0,t.jsx)(n.h2,{id:"stage-1-build",children:"Stage 1: Build"}),"\n",(0,t.jsx)(n.p,{children:"The build stage is responsible for installing dependencies and compiling the application:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'build-job:\n  stage: build\n  image: node:18\n  script:\n    - echo "=== Build Stage ==="\n    - echo "Installing dependencies (Jest and other packages)..."\n    - time npm install\n    - du -sh node_modules/ || echo "node_modules created"\n    - echo "Building the project..."\n    - npm run build\n  cache:\n    key: ${CI_COMMIT_REF_SLUG}\n    paths:\n      - node_modules/\n    policy: push\n  artifacts:\n    paths:\n      - public/\n    expire_in: 1 hour\n  only:\n    - main\n    - merge_requests\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Key Design Decisions"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Docker Image"}),": Uses ",(0,t.jsx)(n.code,{children:"node:18"})," for consistency across all environments"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cache Policy"}),": ",(0,t.jsx)(n.code,{children:"push"})," to save ",(0,t.jsx)(n.code,{children:"node_modules/"})," for downstream jobs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Artifacts"}),": Stores the built ",(0,t.jsx)(n.code,{children:"public/"})," directory for 1 hour"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Branch Rules"}),": Runs on ",(0,t.jsx)(n.code,{children:"main"})," branch and ",(0,t.jsx)(n.code,{children:"merge requests"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The build stage creates the foundation for subsequent stages by caching dependencies and producing build artifacts."}),"\n",(0,t.jsx)(n.h2,{id:"stage-2-test",children:"Stage 2: Test"}),"\n",(0,t.jsx)(n.p,{children:"The test stage validates code quality and generates coverage reports:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'test-job:\n  stage: test\n  image: node:18\n  script:\n    - echo "=== Test Stage ==="\n    - echo "Checking if node_modules cache was restored..."\n    - |\n      if [ -d "node_modules" ]; then\n        echo "\u2705 SUCCESS: node_modules cache was restored!"\n        du -sh node_modules/\n        ls -lh node_modules/.bin/jest\n      else\n        echo "\u274c WARNING: node_modules cache not found"\n      fi\n    - npm test\n  cache:\n    key: ${CI_COMMIT_REF_SLUG}\n    paths:\n      - node_modules/\n    policy: pull\n  coverage: \'/Lines\\s*:\\s*(\\d+\\.\\d+)%/\'\n  artifacts:\n    reports:\n      coverage_report:\n        coverage_format: cobertura\n        path: coverage/cobertura-coverage.xml\n    paths:\n      - coverage/\n    expire_in: 1 week\n  only:\n    - main\n    - merge_requests\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Key Design Decisions"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cache Policy"}),": ",(0,t.jsx)(n.code,{children:"pull"})," only - reuses cached dependencies without updating them"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Coverage Extraction"}),": Uses regex pattern to extract coverage percentage"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Coverage Artifacts"}),": Stores coverage reports in Cobertura format for GitLab integration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Verification Logic"}),": Checks if cache was successfully restored before running tests"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This demonstrates a critical optimization: the test job avoids re-downloading ~50MB of Jest dependencies by pulling from cache."}),"\n",(0,t.jsx)(n.h2,{id:"stage-3-deploy",children:"Stage 3: Deploy"}),"\n",(0,t.jsx)(n.p,{children:"The deploy stage publishes the site to GitLab Pages:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'pages:\n  stage: deploy\n  image: node:18\n  script:\n    - echo "=== Deploy Stage ==="\n    - echo "Deploying to GitLab Pages..."\n    - ls -la public/\n  artifacts:\n    paths:\n      - public\n  only:\n    - main\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Key Design Decisions"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Job Name"}),": Must be named ",(0,t.jsx)(n.code,{children:"pages"})," for GitLab Pages deployment"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Artifacts"}),": Reuses ",(0,t.jsx)(n.code,{children:"public/"})," directory from build stage"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Branch Protection"}),": Only deploys from ",(0,t.jsx)(n.code,{children:"main"})," branch"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Minimal Logic"}),": Simple deployment since build artifacts are already prepared"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"pipeline-design-patterns",children:"Pipeline Design Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"global-cache-configuration",children:"Global Cache Configuration"}),"\n",(0,t.jsxs)(n.p,{children:["The pipeline uses a global cache to share ",(0,t.jsx)(n.code,{children:"node_modules/"})," across jobs:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"cache:\n  key: ${CI_COMMIT_REF_SLUG}\n  paths:\n    - node_modules/\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Why This Matters"}),": Without caching, each job would download dependencies independently, wasting bandwidth and time. The cache key uses ",(0,t.jsx)(n.code,{children:"${CI_COMMIT_REF_SLUG}"})," to create separate caches per branch."]}),"\n",(0,t.jsx)(n.h3,{id:"cache-policy-strategy",children:"Cache Policy Strategy"}),"\n",(0,t.jsx)(n.p,{children:"Different stages use different cache policies:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Build"}),": ",(0,t.jsx)(n.code,{children:"policy: push"})," - creates/updates the cache"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test"}),": ",(0,t.jsx)(n.code,{children:"policy: pull"})," - only reads from cache (faster)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Deploy"}),": No cache needed (uses artifacts instead)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This optimization ensures the test stage runs faster by skipping cache updates."}),"\n",(0,t.jsx)(n.h3,{id:"artifact-management",children:"Artifact Management"}),"\n",(0,t.jsx)(n.p,{children:"Build outputs are passed between stages using artifacts:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"artifacts:\n  paths:\n    - public/\n  expire_in: 1 hour\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"expire_in"})," directive prevents artifact storage from growing indefinitely, saving CI minutes and storage costs."]}),"\n",(0,t.jsx)(n.h2,{id:"cicd-best-practices-demonstrated",children:"CI/CD Best Practices Demonstrated"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Docker Image Pinning"}),": Use specific versions (",(0,t.jsx)(n.code,{children:"node:18"}),") instead of ",(0,t.jsx)(n.code,{children:"latest"})," for reproducibility"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Branch Rules"}),": Deploy only from protected branches to prevent accidental deployments"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fail Fast"}),": Test stage runs quickly using cached dependencies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Artifact Expiration"}),": Set appropriate expiration times to manage storage"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cache Verification"}),": Test stage validates cache restoration before proceeding"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Coverage Reporting"}),": Integrate code coverage into GitLab's UI using Cobertura format"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"pipeline-variables",children:"Pipeline Variables"}),"\n",(0,t.jsx)(n.p,{children:"GitLab provides built-in variables that make pipelines dynamic:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"${CI_COMMIT_REF_SLUG}"}),": Sanitized branch name, perfect for cache keys"]}),"\n",(0,t.jsx)(n.li,{children:"Jobs execute in isolated Docker containers with clean environments"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"monitoring-pipeline-performance",children:"Monitoring Pipeline Performance"}),"\n",(0,t.jsx)(n.p,{children:"When reviewing your pipeline, check:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cache Hit Rate"}),": Verify the test stage successfully pulls cached dependencies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stage Duration"}),": Identify bottlenecks in build, test, or deploy stages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Artifact Size"}),": Monitor storage consumption"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Coverage Trends"}),": Track code coverage over time"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"extending-the-pipeline",children:"Extending the Pipeline"}),"\n",(0,t.jsx)(n.h3,{id:"adding-security-scanning",children:"Adding Security Scanning"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"stages:\n  - build\n  - test\n  - security\n  - deploy\n\nsecurity-scan:\n  stage: security\n  image: node:18\n  script:\n    - npm audit\n  allow_failure: true\n  only:\n    - main\n    - merge_requests\n"})}),"\n",(0,t.jsx)(n.h3,{id:"multi-environment-deployments",children:"Multi-Environment Deployments"}),"\n",(0,t.jsxs)(n.p,{children:["GitLab ",(0,t.jsx)(n.a,{href:"https://docs.gitlab.com/ee/ci/environments/",children:"environments"})," allow you to track deployments across different stages (development, staging, production) with built-in monitoring and rollback capabilities."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'deploy-staging:\n  stage: deploy\n  script:\n    - echo "Deploy to staging"\n  environment:\n    name: staging\n    url: https://staging.example.com\n  only:\n    - develop\n\ndeploy-production:\n  stage: deploy\n  script:\n    - echo "Deploy to production"\n  environment:\n    name: production\n    url: https://production.example.com\n  only:\n    - main\n'})}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"This pipeline demonstrates how to build a robust CI/CD workflow with GitLab. The key takeaways:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Caching"})," dramatically speeds up pipeline execution"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Artifacts"})," enable passing build outputs between stages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Branch rules"})," provide deployment safety"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Docker containers"})," ensure consistent environments"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Coverage reporting"})," integrates testing into your workflow"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Check out the ",(0,t.jsx)(n.a,{href:"https://gitlab.com/kristina-portfolio/gitlab-cicd-pipeline-example",children:"full implementation"})," to see these concepts in action."]}),"\n",(0,t.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://docs.gitlab.com/ee/ci/",children:"GitLab CI/CD Documentation"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://docs.gitlab.com/ee/ci/yaml/",children:".gitlab-ci.yml Reference"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://gitlab.com/kristina-portfolio/gitlab-cicd-pipeline-example",children:"Example Project Repository"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},5874:e=>{e.exports=JSON.parse('{"permalink":"/portfolio/blog/gitlab-cicd-pipelines","source":"@site/blog/2026-11-22-gitlab-cicd.md","title":"Building CI/CD Pipelines with GitLab","description":"A comprehensive guide to designing and implementing automated deployment pipelines using GitLab CI/CD, featuring a real-world example with caching, artifacts, and GitLab Pages deployment.","date":"2026-11-22T00:00:00.000Z","tags":[{"inline":false,"label":"CI/CD","permalink":"/portfolio/blog/tags/cicd","description":"Continuous Integration and Continuous Deployment"},{"inline":false,"label":"GitLab","permalink":"/portfolio/blog/tags/gitlab","description":"GitLab platform and CI/CD"},{"inline":false,"label":"DevOps","permalink":"/portfolio/blog/tags/devops","description":"DevOps practices and tools"},{"inline":false,"label":"Automation","permalink":"/portfolio/blog/tags/automation","description":"Automation tools and techniques"}],"readingTime":4.61,"hasTruncateMarker":true,"authors":[{"name":"Kristina Haynes","title":"DevOps Engineer & Full Stack Developer","url":"https://www.linkedin.com/in/kristina-haynes-94915147","page":{"permalink":"/portfolio/blog/authors/kristina-haynes"},"socials":{"linkedin":"https://www.linkedin.com/in/kristina-haynes-94915147","github":"https://github.com/ForeverAProgrammer"},"imageURL":"https://avatars.githubusercontent.com/u/21247589?v=4","key":"kristina-haynes"}],"frontMatter":{"slug":"gitlab-cicd-pipelines","title":"Building CI/CD Pipelines with GitLab","authors":["kristina-haynes"],"tags":["cicd","gitlab","devops","automation"]},"unlisted":false,"nextItem":{"title":"Understanding SQL Injection Through a Real-World Example","permalink":"/portfolio/blog/sql-injection-apostrophe-lesson"}}')},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var s=i(6540);const t={},l=s.createContext(t);function r(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);