"use strict";(globalThis.webpackChunkmy_profile_site=globalThis.webpackChunkmy_profile_site||[]).push([[2033],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(96540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}},78220:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"design-patterns/structural/facade","title":"Facade Pattern","description":"Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.","source":"@site/docs/design-patterns/structural/facade.md","sourceDirName":"design-patterns/structural","slug":"/design-patterns/structural/facade","permalink":"/docs/design-patterns/structural/facade","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Adapter Pattern","permalink":"/docs/design-patterns/structural/adapter"},"next":{"title":"Composite Pattern","permalink":"/docs/design-patterns/structural/composite"}}');var s=t(74848),r=t(28453);const a={sidebar_position:3},l="Facade Pattern",o={},c=[{value:"Problem",id:"problem",level:2},{value:"Design Principles Applied",id:"design-principles-applied",level:2},{value:"UML Diagram",id:"uml-diagram",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Example 1: Home Theater System",id:"example-1-home-theater-system",level:3},{value:"Benefits",id:"benefits",level:2},{value:"Drawbacks",id:"drawbacks",level:2},{value:"When to Use",id:"when-to-use",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"facade-pattern",children:"Facade Pattern"})}),"\n",(0,s.jsx)(n.p,{children:"Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use."}),"\n",(0,s.jsx)(n.h2,{id:"problem",children:"Problem"}),"\n",(0,s.jsx)(n.p,{children:"Complex subsystems with multiple interdependent classes are difficult to use. Clients need a simpler way to interact with the subsystem without understanding all its complexity."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Common Scenarios:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Simplifying complex libraries or frameworks"}),"\n",(0,s.jsx)(n.li,{children:"Providing a clean API to legacy code"}),"\n",(0,s.jsx)(n.li,{children:"Wrapping third-party libraries"}),"\n",(0,s.jsx)(n.li,{children:"Creating a simplified interface to complex systems"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"design-principles-applied",children:"Design Principles Applied"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Principle of Least Knowledge"})," - Talk only to your immediate friends"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Encapsulation"})," - Hide complex subsystem implementation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Single Responsibility"})," - Facade provides one simplified interface"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"uml-diagram",children:"UML Diagram"}),"\n",(0,s.jsx)(n.mermaid,{value:'classDiagram\n    class Client {\n        <<actor>>\n    }\n    class Facade {\n        +operation()\n    }\n    class SubsystemA {\n        +operationA()\n    }\n    class SubsystemB {\n        +operationB()\n    }\n    class SubsystemC {\n        +operationC()\n    }\n    note for Client "Represents any code that uses the pattern, not a concrete class"\n    Client --\x3e Facade\n    Facade --\x3e SubsystemA\n    Facade --\x3e SubsystemB\n    Facade --\x3e SubsystemC'}),"\n",(0,s.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"example-1-home-theater-system",children:"Example 1: Home Theater System"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Complex subsystem classes\npublic class Amplifier {\n    public void on() {\n        System.out.println("Amplifier on");\n    }\n\n    public void off() {\n        System.out.println("Amplifier off");\n    }\n\n    public void setVolume(int level) {\n        System.out.println("Amplifier volume set to " + level);\n    }\n}\n\npublic class DvdPlayer {\n    public void on() {\n        System.out.println("DVD Player on");\n    }\n\n    public void off() {\n        System.out.println("DVD Player off");\n    }\n\n    public void play(String movie) {\n        System.out.println("Playing \'" + movie + "\'");\n    }\n\n    public void stop() {\n        System.out.println("DVD Player stopped");\n    }\n}\n\npublic class Projector {\n    public void on() {\n        System.out.println("Projector on");\n    }\n\n    public void off() {\n        System.out.println("Projector off");\n    }\n\n    public void wideScreenMode() {\n        System.out.println("Projector in widescreen mode");\n    }\n}\n\npublic class Lights {\n    public void dim(int level) {\n        System.out.println("Lights dimmed to " + level + "%");\n    }\n\n    public void on() {\n        System.out.println("Lights on");\n    }\n}\n\n// Facade - Simplifies the subsystem\npublic class HomeTheaterFacade {\n    private Amplifier amp;\n    private DvdPlayer dvd;\n    private Projector projector;\n    private Lights lights;\n\n    public HomeTheaterFacade(Amplifier amp, DvdPlayer dvd,\n                             Projector projector, Lights lights) {\n        this.amp = amp;\n        this.dvd = dvd;\n        this.projector = projector;\n        this.lights = lights;\n    }\n\n    public void watchMovie(String movie) {\n        System.out.println("Get ready to watch a movie...");\n        lights.dim(10);\n        projector.on();\n        projector.wideScreenMode();\n        amp.on();\n        amp.setVolume(5);\n        dvd.on();\n        dvd.play(movie);\n    }\n\n    public void endMovie() {\n        System.out.println("Shutting movie theater down...");\n        dvd.stop();\n        dvd.off();\n        amp.off();\n        projector.off();\n        lights.on();\n    }\n}\n\n// Client code - Much simpler!\npublic class HomeTheaterTest {\n    public static void main(String[] args) {\n        // Create subsystem components\n        Amplifier amp = new Amplifier();\n        DvdPlayer dvd = new DvdPlayer();\n        Projector projector = new Projector();\n        Lights lights = new Lights();\n\n        // Create facade\n        HomeTheaterFacade homeTheater =\n            new HomeTheaterFacade(amp, dvd, projector, lights);\n\n        // Simple interface\n        homeTheater.watchMovie("Raiders of the Lost Ark");\n        System.out.println();\n        homeTheater.endMovie();\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"benefits",children:"Benefits"}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Simplified interface"})," - Hide complex subsystem complexity\n\u2705 ",(0,s.jsx)(n.strong,{children:"Decoupling"})," - Client code doesn't depend on subsystem classes\n\u2705 ",(0,s.jsx)(n.strong,{children:"Easier to use"})," - One method call instead of many\n\u2705 ",(0,s.jsx)(n.strong,{children:"Flexibility"})," - Can change subsystem without affecting clients"]}),"\n",(0,s.jsx)(n.h2,{id:"drawbacks",children:"Drawbacks"}),"\n",(0,s.jsxs)(n.p,{children:["\u274c ",(0,s.jsx)(n.strong,{children:"God object risk"})," - Facade can become too large\n\u274c ",(0,s.jsx)(n.strong,{children:"Limited functionality"})," - May not expose all subsystem features\n\u274c ",(0,s.jsx)(n.strong,{children:"Additional layer"})," - Adds another abstraction"]}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Use Facade When:"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You want to provide a simple interface to a complex subsystem"}),"\n",(0,s.jsx)(n.li,{children:"There are many dependencies between clients and implementation classes"}),"\n",(0,s.jsx)(n.li,{children:"You want to layer your subsystems"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["\u274c ",(0,s.jsx)(n.strong,{children:"Don't Use When:"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The subsystem is already simple"}),"\n",(0,s.jsx)(n.li,{children:"You need access to all low-level functionality"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"The Facade Pattern simplifies complex subsystems by providing a unified, easy-to-use interface."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key Takeaway:"})," Use Facade to make complex systems easier to use, not to restrict functionality."]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);