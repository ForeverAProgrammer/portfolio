"use strict";(globalThis.webpackChunkmy_profile_site=globalThis.webpackChunkmy_profile_site||[]).push([[8622],{28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var t=i(96540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}},69048:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"design-patterns/structural/bridge","title":"Bridge Pattern","description":"Decouple an abstraction from its implementation so that the two can vary independently.","source":"@site/docs/design-patterns/structural/bridge.md","sourceDirName":"design-patterns/structural","slug":"/design-patterns/structural/bridge","permalink":"/docs/design-patterns/structural/bridge","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Proxy Pattern","permalink":"/docs/design-patterns/structural/proxy"},"next":{"title":"Flyweight Pattern","permalink":"/docs/design-patterns/structural/flyweight"}}');var r=i(74848),s=i(28453);const a={sidebar_position:6},l="Bridge Pattern",o={},d=[{value:"Problem",id:"problem",level:2},{value:"Design Principles Applied",id:"design-principles-applied",level:2},{value:"UML Diagram",id:"uml-diagram",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Example 1: Shape and Drawing API",id:"example-1-shape-and-drawing-api",level:3},{value:"Step 1: Implementor Interface",id:"step-1-implementor-interface",level:3},{value:"Step 2: Concrete Implementors",id:"step-2-concrete-implementors",level:3},{value:"Step 3: Abstraction",id:"step-3-abstraction",level:3},{value:"Step 4: Refined Abstractions",id:"step-4-refined-abstractions",level:3},{value:"Step 5: Client Code",id:"step-5-client-code",level:3},{value:"Example 2: Remote Control and Devices",id:"example-2-remote-control-and-devices",level:2},{value:"Real-World Examples",id:"real-world-examples",level:2},{value:"JDBC \u2014 The Classic Java Bridge",id:"jdbc--the-classic-java-bridge",level:3},{value:"SLF4J Logging",id:"slf4j-logging",level:3},{value:"Benefits",id:"benefits",level:2},{value:"Drawbacks",id:"drawbacks",level:2},{value:"When to Use",id:"when-to-use",level:2},{value:"Bridge vs Adapter",id:"bridge-vs-adapter",level:2},{value:"Bridge vs Strategy",id:"bridge-vs-strategy",level:2},{value:"Related Patterns",id:"related-patterns",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"bridge-pattern",children:"Bridge Pattern"})}),"\n",(0,r.jsx)(n.p,{children:"Decouple an abstraction from its implementation so that the two can vary independently."}),"\n",(0,r.jsx)(n.h2,{id:"problem",children:"Problem"}),"\n",(0,r.jsx)(n.p,{children:"You have a class hierarchy that is growing in two independent dimensions \u2014 for example, shape types and rendering methods \u2014 and combining them through inheritance causes a class explosion."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Common Scenarios:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"UI components that need to support multiple platforms (Windows, macOS, Linux)"}),"\n",(0,r.jsx)(n.li,{children:"Shapes that can be rendered in different graphics APIs"}),"\n",(0,r.jsx)(n.li,{children:"Devices that can be controlled by different remote control types"}),"\n",(0,r.jsx)(n.li,{children:"Database drivers that separate SQL dialect from connection handling"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"design-principles-applied",children:"Design Principles Applied"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Favor composition over inheritance"})," \u2014 implementation is held as a field, not inherited"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Program to an interface, not an implementation"})," \u2014 abstraction uses the implementor interface"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Encapsulate what varies"})," \u2014 the two dimensions (abstraction and implementation) vary independently"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"uml-diagram",children:"UML Diagram"}),"\n",(0,r.jsx)(n.mermaid,{value:"classDiagram\n    class Abstraction {\n        -Implementor impl\n        +operation()\n    }\n    class RefinedAbstraction {\n        +refinedOperation()\n    }\n    class Implementor {\n        <<interface>>\n        +operationImpl()\n    }\n    class ConcreteImplA {\n        +operationImpl()\n    }\n    class ConcreteImplB {\n        +operationImpl()\n    }\n\n    Abstraction <|-- RefinedAbstraction : extends\n    Abstraction o-- Implementor : impl\n    Implementor <|.. ConcreteImplA : implements\n    Implementor <|.. ConcreteImplB : implements"}),"\n",(0,r.jsx)(n.p,{children:"The abstraction holds a reference to the implementor. Subclasses of the abstraction and implementations can both vary without affecting each other."}),"\n",(0,r.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"example-1-shape-and-drawing-api",children:"Example 1: Shape and Drawing API"}),"\n",(0,r.jsx)(n.p,{children:"Without Bridge, combining 3 shapes \xd7 2 rendering APIs requires 6 classes. With Bridge, you need 3 + 2 = 5."}),"\n",(0,r.jsx)(n.h3,{id:"step-1-implementor-interface",children:"Step 1: Implementor Interface"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Implementor \u2014 defines the interface for the implementation side\npublic interface DrawingAPI {\n    void drawCircle(double x, double y, double radius);\n    void drawRectangle(double x1, double y1, double x2, double y2);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-2-concrete-implementors",children:"Step 2: Concrete Implementors"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Concrete Implementor A \u2014 one rendering engine\npublic class DrawingAPI1 implements DrawingAPI {\n\n    @Override\n    public void drawCircle(double x, double y, double radius) {\n        System.out.printf("API1: Drawing circle at (%.1f, %.1f) radius %.1f%n",\n            x, y, radius);\n    }\n\n    @Override\n    public void drawRectangle(double x1, double y1, double x2, double y2) {\n        System.out.printf("API1: Drawing rectangle (%.1f,%.1f) to (%.1f,%.1f)%n",\n            x1, y1, x2, y2);\n    }\n}\n\n// Concrete Implementor B \u2014 different rendering engine\npublic class DrawingAPI2 implements DrawingAPI {\n\n    @Override\n    public void drawCircle(double x, double y, double radius) {\n        System.out.printf("API2: Circle [x=%.1f y=%.1f r=%.1f]%n",\n            x, y, radius);\n    }\n\n    @Override\n    public void drawRectangle(double x1, double y1, double x2, double y2) {\n        System.out.printf("API2: Rect [%.1f,%.1f \u2192 %.1f,%.1f]%n",\n            x1, y1, x2, y2);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"step-3-abstraction",children:"Step 3: Abstraction"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Abstraction \u2014 holds a reference to the Implementor\npublic abstract class Shape {\n    protected DrawingAPI drawingAPI;\n\n    protected Shape(DrawingAPI drawingAPI) {\n        this.drawingAPI = drawingAPI;\n    }\n\n    public abstract void draw();\n    public abstract void resize(double factor);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-4-refined-abstractions",children:"Step 4: Refined Abstractions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"// Refined Abstraction \u2014 Circle\npublic class Circle extends Shape {\n    private double x, y, radius;\n\n    public Circle(double x, double y, double radius, DrawingAPI drawingAPI) {\n        super(drawingAPI);\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n\n    @Override\n    public void draw() {\n        drawingAPI.drawCircle(x, y, radius);\n    }\n\n    @Override\n    public void resize(double factor) {\n        radius *= factor;\n    }\n}\n\n// Refined Abstraction \u2014 Rectangle\npublic class Rectangle extends Shape {\n    private double x1, y1, x2, y2;\n\n    public Rectangle(double x1, double y1, double x2, double y2,\n                     DrawingAPI drawingAPI) {\n        super(drawingAPI);\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n\n    @Override\n    public void draw() {\n        drawingAPI.drawRectangle(x1, y1, x2, y2);\n    }\n\n    @Override\n    public void resize(double factor) {\n        x2 *= factor;\n        y2 *= factor;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-5-client-code",children:"Step 5: Client Code"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public class BridgeDemo {\n    public static void main(String[] args) {\n        DrawingAPI api1 = new DrawingAPI1();\n        DrawingAPI api2 = new DrawingAPI2();\n\n        // Same Circle shape, different rendering engines\n        Shape circle1 = new Circle(5, 10, 3, api1);\n        Shape circle2 = new Circle(5, 10, 3, api2);\n\n        circle1.draw(); // API1: Drawing circle at (5.0, 10.0) radius 3.0\n        circle2.draw(); // API2: Circle [x=5.0 y=10.0 r=3.0]\n\n        // Resize and redraw \u2014 shape logic is independent of rendering\n        circle1.resize(2);\n        circle1.draw(); // API1: Drawing circle at (5.0, 10.0) radius 6.0\n\n        // Rectangle with API2\n        Shape rect = new Rectangle(0, 0, 10, 5, api2);\n        rect.draw();    // API2: Rect [0.0,0.0 \u2192 10.0,5.0]\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"example-2-remote-control-and-devices",children:"Example 2: Remote Control and Devices"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// Implementor \u2014 device interface\npublic interface Device {\n    boolean isEnabled();\n    void enable();\n    void disable();\n    int getVolume();\n    void setVolume(int percent);\n    int getChannel();\n    void setChannel(int channel);\n    void printStatus();\n}\n\n// Concrete Implementors\npublic class TV implements Device {\n    private boolean on = false;\n    private int volume = 30;\n    private int channel = 1;\n\n    @Override\n    public boolean isEnabled() { return on; }\n\n    @Override\n    public void enable() {\n        on = true;\n        System.out.println("TV: powered ON");\n    }\n\n    @Override\n    public void disable() {\n        on = false;\n        System.out.println("TV: powered OFF");\n    }\n\n    @Override\n    public int getVolume() { return volume; }\n\n    @Override\n    public void setVolume(int volume) {\n        this.volume = Math.max(0, Math.min(100, volume));\n        System.out.println("TV: volume set to " + this.volume);\n    }\n\n    @Override\n    public int getChannel() { return channel; }\n\n    @Override\n    public void setChannel(int channel) {\n        this.channel = channel;\n        System.out.println("TV: channel set to " + channel);\n    }\n\n    @Override\n    public void printStatus() {\n        System.out.printf("TV [%s] vol=%d ch=%d%n",\n            on ? "ON" : "OFF", volume, channel);\n    }\n}\n\npublic class Radio implements Device {\n    private boolean on = false;\n    private int volume = 20;\n    private int channel = 1;\n\n    @Override\n    public boolean isEnabled() { return on; }\n\n    @Override\n    public void enable() { on = true; System.out.println("Radio: ON"); }\n\n    @Override\n    public void disable() { on = false; System.out.println("Radio: OFF"); }\n\n    @Override\n    public int getVolume() { return volume; }\n\n    @Override\n    public void setVolume(int volume) {\n        this.volume = Math.max(0, Math.min(100, volume));\n    }\n\n    @Override\n    public int getChannel() { return channel; }\n\n    @Override\n    public void setChannel(int channel) { this.channel = channel; }\n\n    @Override\n    public void printStatus() {\n        System.out.printf("Radio [%s] vol=%d ch=%d%n",\n            on ? "ON" : "OFF", volume, channel);\n    }\n}\n\n// Abstraction \u2014 remote control\npublic class RemoteControl {\n    protected Device device;\n\n    public RemoteControl(Device device) {\n        this.device = device;\n    }\n\n    public void togglePower() {\n        if (device.isEnabled()) {\n            device.disable();\n        } else {\n            device.enable();\n        }\n    }\n\n    public void volumeUp() {\n        device.setVolume(device.getVolume() + 10);\n    }\n\n    public void volumeDown() {\n        device.setVolume(device.getVolume() - 10);\n    }\n\n    public void channelUp() {\n        device.setChannel(device.getChannel() + 1);\n    }\n\n    public void channelDown() {\n        device.setChannel(device.getChannel() - 1);\n    }\n}\n\n// Refined Abstraction \u2014 advanced remote with extra features\npublic class AdvancedRemoteControl extends RemoteControl {\n\n    public AdvancedRemoteControl(Device device) {\n        super(device);\n    }\n\n    public void mute() {\n        device.setVolume(0);\n        System.out.println("Remote: muted");\n    }\n\n    public void setChannel(int channel) {\n        device.setChannel(channel);\n    }\n}\n\n// Client\npublic class RemoteDemo {\n    public static void main(String[] args) {\n        // Basic remote with TV\n        Device tv = new TV();\n        RemoteControl remote = new RemoteControl(tv);\n        remote.togglePower();  // TV: powered ON\n        remote.volumeUp();     // TV: volume set to 40\n        tv.printStatus();      // TV [ON] vol=40 ch=1\n\n        // Advanced remote with Radio \u2014 same remote abstraction, different device\n        Device radio = new Radio();\n        AdvancedRemoteControl advRemote = new AdvancedRemoteControl(radio);\n        advRemote.togglePower();\n        advRemote.setChannel(5);\n        advRemote.mute();\n        radio.printStatus();\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,r.jsx)(n.h3,{id:"jdbc--the-classic-java-bridge",children:"JDBC \u2014 The Classic Java Bridge"}),"\n",(0,r.jsxs)(n.p,{children:["JDBC is the most well-known Bridge implementation in Java. ",(0,r.jsx)(n.code,{children:"Connection"}),", ",(0,r.jsx)(n.code,{children:"Statement"}),", and ",(0,r.jsx)(n.code,{children:"ResultSet"})," are the abstraction layer; each database vendor provides a ",(0,r.jsx)(n.code,{children:"Driver"})," as the concrete implementor."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'// The abstraction (your code) stays the same regardless of database\npublic class UserRepository {\n    private final Connection connection;  // Bridge: holds the implementor\n\n    public UserRepository(Connection connection) {\n        this.connection = connection;\n    }\n\n    public List<String> findAllUsers() throws SQLException {\n        List<String> users = new ArrayList<>();\n        try (Statement stmt = connection.createStatement();\n             ResultSet rs = stmt.executeQuery("SELECT name FROM users")) {\n            while (rs.next()) {\n                users.add(rs.getString("name"));\n            }\n        }\n        return users;\n    }\n}\n\n// Swap the implementor (driver) without changing UserRepository at all\nConnection mysqlConn = DriverManager.getConnection(\n    "jdbc:mysql://localhost/mydb", "user", "pass");\n\nConnection postgresConn = DriverManager.getConnection(\n    "jdbc:postgresql://localhost/mydb", "user", "pass");\n\nUserRepository mysqlRepo = new UserRepository(mysqlConn);\nUserRepository postgresRepo = new UserRepository(postgresConn);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"slf4j-logging",children:"SLF4J Logging"}),"\n",(0,r.jsx)(n.p,{children:"SLF4J (Simple Logging Facade for Java) is a Bridge between application code and logging frameworks (Logback, Log4j, java.util.logging)."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class OrderService {\n    // Abstraction \u2014 SLF4J Logger interface\n    private static final Logger logger =\n        LoggerFactory.getLogger(OrderService.class);\n\n    public void processOrder(Order order) {\n        logger.info("Processing order {}", order.getId());\n        // ...\n        logger.debug("Order details: {}", order);\n    }\n    // Switch from Logback to Log4j by swapping the dependency \u2014\n    // no changes to this class required\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"benefits",children:"Benefits"}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Independent variation"})," \u2014 abstraction and implementation can be extended without affecting each other"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Avoids class explosion"})," \u2014 m abstractions \xd7 n implementations requires m + n classes, not m \xd7 n"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Swap implementations at runtime"})," \u2014 set a different implementor on the abstraction at any point"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Single Responsibility"})," \u2014 abstraction handles high-level logic; implementor handles low-level details"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Open/Closed Principle"})," \u2014 add new abstractions or implementations without modifying existing ones"]}),"\n",(0,r.jsx)(n.h2,{id:"drawbacks",children:"Drawbacks"}),"\n",(0,r.jsxs)(n.p,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"More complex upfront"})," \u2014 introduces extra layers and interfaces even for simple cases"]}),"\n",(0,r.jsxs)(n.p,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Indirection overhead"})," \u2014 every abstraction call delegates to the implementor, adding one level of indirection"]}),"\n",(0,r.jsxs)(n.p,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Harder to follow"})," \u2014 the split between abstraction and implementation can be confusing at first glance"]}),"\n",(0,r.jsx)(n.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Use Bridge When:"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A class varies in two independent dimensions (e.g. type AND platform)"}),"\n",(0,r.jsx)(n.li,{children:"You want to switch implementations at runtime"}),"\n",(0,r.jsx)(n.li,{children:"You want to avoid a permanent binding between abstraction and implementation"}),"\n",(0,r.jsx)(n.li,{children:"Both the abstraction and its implementation should be extensible via subclassing"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["\u274c ",(0,r.jsx)(n.strong,{children:"Don't Use Bridge When:"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"There is only one implementation \u2014 the extra interface adds no value"}),"\n",(0,r.jsx)(n.li,{children:"The abstraction and implementation will never vary independently \u2014 simple inheritance is clearer"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"bridge-vs-adapter",children:"Bridge vs Adapter"}),"\n",(0,r.jsx)(n.p,{children:"These two patterns look similar but solve different problems:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Aspect"}),(0,r.jsx)(n.th,{children:"Bridge"}),(0,r.jsx)(n.th,{children:"Adapter"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Intent"})}),(0,r.jsx)(n.td,{children:"Decouple abstraction from implementation upfront"}),(0,r.jsx)(n.td,{children:"Make incompatible interfaces work together after the fact"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Design time"})}),(0,r.jsx)(n.td,{children:"Designed in from the start"}),(0,r.jsx)(n.td,{children:"Applied to existing code"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Structure"})}),(0,r.jsx)(n.td,{children:"Two parallel hierarchies"}),(0,r.jsx)(n.td,{children:"Wraps one interface to match another"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Focus"})}),(0,r.jsx)(n.td,{children:"Variation in two dimensions"}),(0,r.jsx)(n.td,{children:"Interface compatibility"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"bridge-vs-strategy",children:"Bridge vs Strategy"}),"\n",(0,r.jsx)(n.p,{children:"Both patterns delegate work to a separately defined interface held as a field. The difference is in scope:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Aspect"}),(0,r.jsx)(n.th,{children:"Bridge"}),(0,r.jsx)(n.th,{children:"Strategy"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Scope"})}),(0,r.jsx)(n.td,{children:"Structural \u2014 shapes the entire class hierarchy"}),(0,r.jsx)(n.td,{children:"Behavioral \u2014 swaps one algorithm"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Hierarchies"})}),(0,r.jsx)(n.td,{children:"Both sides can have subclass hierarchies"}),(0,r.jsx)(n.td,{children:"Typically one context class, many strategies"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Purpose"})}),(0,r.jsx)(n.td,{children:"Decouple two dimensions of variation"}),(0,r.jsx)(n.td,{children:"Make algorithms interchangeable"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"related-patterns",children:"Related Patterns"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Adapter"})," \u2014 also maps one interface to another, but is applied to fix existing incompatibilities rather than designed in from the start"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Abstract Factory"})," \u2014 can be used to create the concrete implementors and inject them into the abstraction"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Strategy"})," \u2014 similar structure (composition of an interface), but behavioral rather than structural in intent"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Bridge splits a class into two hierarchies: abstraction and implementation"}),"\n",(0,r.jsx)(n.li,{children:"The abstraction holds a reference to the implementor \u2014 it does not inherit from it"}),"\n",(0,r.jsx)(n.li,{children:"Both hierarchies can grow independently without affecting each other"}),"\n",(0,r.jsx)(n.li,{children:"JDBC and SLF4J are the most prominent Bridge examples in the Java ecosystem"}),"\n",(0,r.jsx)(n.li,{children:"Prefer Bridge over deep inheritance trees when two dimensions vary independently"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"The Bridge Pattern decouples what something does (abstraction) from how it does it (implementation), letting both evolve without touching each other."})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);