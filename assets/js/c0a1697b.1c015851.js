"use strict";(globalThis.webpackChunkmy_profile_site=globalThis.webpackChunkmy_profile_site||[]).push([[3252],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var i=t(96540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}},35906:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"design-patterns/behavioral/template-method","title":"Template Method Pattern","description":"Define the skeleton of an algorithm in a method, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm\'s structure.","source":"@site/docs/design-patterns/behavioral/template-method.md","sourceDirName":"design-patterns/behavioral","slug":"/design-patterns/behavioral/template-method","permalink":"/docs/design-patterns/behavioral/template-method","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Command Pattern","permalink":"/docs/design-patterns/behavioral/command"},"next":{"title":"Iterator Pattern","permalink":"/docs/design-patterns/behavioral/iterator"}}');var s=t(74848),a=t(28453);const r={sidebar_position:4},l="Template Method Pattern",o={},d=[{value:"Problem",id:"problem",level:2},{value:"Design Principles Applied",id:"design-principles-applied",level:2},{value:"UML Diagram",id:"uml-diagram",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Example: Beverage Preparation",id:"example-beverage-preparation",level:3},{value:"Step 1: Abstract Template Class",id:"step-1-abstract-template-class",level:3},{value:"Step 2: Concrete Implementations",id:"step-2-concrete-implementations",level:3},{value:"Step 3: Client Code",id:"step-3-client-code",level:3},{value:"Real-World Examples",id:"real-world-examples",level:2},{value:"Example 2: Data Mining Application",id:"example-2-data-mining-application",level:3},{value:"Example 3: Game Template",id:"example-3-game-template",level:3},{value:"Hook Methods",id:"hook-methods",level:2},{value:"Java API Examples",id:"java-api-examples",level:2},{value:"Collections.sort()",id:"collectionssort",level:3},{value:"InputStream.read()",id:"inputstreamread",level:3},{value:"HttpServlet",id:"httpservlet",level:3},{value:"Template Method vs Strategy",id:"template-method-vs-strategy",level:2},{value:"Advantages",id:"advantages",level:2},{value:"Disadvantages",id:"disadvantages",level:2},{value:"When to Use",id:"when-to-use",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Make Template Method Final",id:"1-make-template-method-final",level:3},{value:"2. Minimize Abstract Methods",id:"2-minimize-abstract-methods",level:3},{value:"3. Document Hook Points",id:"3-document-hook-points",level:3},{value:"4. Use Meaningful Names",id:"4-use-meaningful-names",level:3},{value:"Related Patterns",id:"related-patterns",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"template-method-pattern",children:"Template Method Pattern"})}),"\n",(0,s.jsx)(n.p,{children:"Define the skeleton of an algorithm in a method, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure."}),"\n",(0,s.jsx)(n.h2,{id:"problem",children:"Problem"}),"\n",(0,s.jsx)(n.p,{children:"You have several classes that implement similar algorithms with only minor differences in certain steps. You want to eliminate code duplication while allowing subclasses to customize specific steps."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Common Scenarios:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Data processing workflows with common structure"}),"\n",(0,s.jsx)(n.li,{children:"Game initialization sequences"}),"\n",(0,s.jsx)(n.li,{children:"Document generation with different formats"}),"\n",(0,s.jsx)(n.li,{children:"Testing frameworks with setup/teardown steps"}),"\n",(0,s.jsx)(n.li,{children:"Database connection patterns"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"design-principles-applied",children:"Design Principles Applied"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hollywood Principle"})," - Don't call us, we'll call you (parent calls subclass)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Encapsulate what varies"})," - Variable steps are in subclass methods"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Open/Closed Principle"})," - Open for extension, closed for modification"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Code Reuse"})," - Common algorithm in one place"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"uml-diagram",children:"UML Diagram"}),"\n",(0,s.jsx)(n.mermaid,{value:'classDiagram\n    class AbstractClass {\n        +templateMethod() final\n        #primitiveOperation1()*\n        #primitiveOperation2()*\n        #hook()\n    }\n    class ConcreteA {\n        #primitiveOperation1()\n        #primitiveOperation2()\n        #hook()\n    }\n    class ConcreteB {\n        #primitiveOperation1()\n        #primitiveOperation2()\n    }\n    note for AbstractClass "templateMethod() calls: 1. primitiveOperation1() \xb7 2. primitiveOperation2() \xb7 3. hook()"\n    AbstractClass <|-- ConcreteA : extends\n    AbstractClass <|-- ConcreteB : extends'}),"\n",(0,s.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"example-beverage-preparation",children:"Example: Beverage Preparation"}),"\n",(0,s.jsx)(n.h3,{id:"step-1-abstract-template-class",children:"Step 1: Abstract Template Class"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Abstract class with template method\npublic abstract class CaffeineBeverage {\n\n    // Template method - defines the algorithm skeleton\n    // final prevents subclasses from overriding the sequence\n    public final void prepareRecipe() {\n        boilWater();\n        brew();\n        pourInCup();\n        if (customerWantsCondiments()) { // Hook method\n            addCondiments();\n        }\n    }\n\n    // Abstract methods - must be implemented by subclasses\n    protected abstract void brew();\n    protected abstract void addCondiments();\n\n    // Concrete methods - same for all subclasses\n    private void boilWater() {\n        System.out.println("Boiling water");\n    }\n\n    private void pourInCup() {\n        System.out.println("Pouring into cup");\n    }\n\n    // Hook method - subclass can override but doesn\'t have to\n    protected boolean customerWantsCondiments() {\n        return true; // Default behavior\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-concrete-implementations",children:"Step 2: Concrete Implementations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Concrete class - Coffee\npublic class Coffee extends CaffeineBeverage {\n\n    @Override\n    protected void brew() {\n        System.out.println("Dripping coffee through filter");\n    }\n\n    @Override\n    protected void addCondiments() {\n        System.out.println("Adding sugar and milk");\n    }\n\n    @Override\n    protected boolean customerWantsCondiments() {\n        String answer = getUserInput();\n        return answer.toLowerCase().startsWith("y");\n    }\n\n    private String getUserInput() {\n        System.out.print("Would you like milk and sugar with your coffee (y/n)? ");\n        String answer = "n"; // Simulated input\n        System.out.println(answer);\n        return answer;\n    }\n}\n\n// Concrete class - Tea\npublic class Tea extends CaffeineBeverage {\n\n    @Override\n    protected void brew() {\n        System.out.println("Steeping the tea");\n    }\n\n    @Override\n    protected void addCondiments() {\n        System.out.println("Adding lemon");\n    }\n\n    @Override\n    protected boolean customerWantsCondiments() {\n        String answer = getUserInput();\n        return answer.toLowerCase().startsWith("y");\n    }\n\n    private String getUserInput() {\n        System.out.print("Would you like lemon with your tea (y/n)? ");\n        String answer = "y"; // Simulated input\n        System.out.println(answer);\n        return answer;\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-3-client-code",children:"Step 3: Client Code"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class BeverageTest {\n    public static void main(String[] args) {\n        System.out.println("Making tea...");\n        CaffeineBeverage tea = new Tea();\n        tea.prepareRecipe();\n\n        System.out.println("\\nMaking coffee...");\n        CaffeineBeverage coffee = new Coffee();\n        coffee.prepareRecipe();\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Output:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Making tea...\nBoiling water\nSteeping the tea\nPouring into cup\nWould you like lemon with your tea (y/n)? y\nAdding lemon\n\nMaking coffee...\nBoiling water\nDripping coffee through filter\nPouring into cup\nWould you like milk and sugar with your coffee (y/n)? n\n"})}),"\n",(0,s.jsx)(n.h2,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,s.jsx)(n.h3,{id:"example-2-data-mining-application",children:"Example 2: Data Mining Application"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'// Abstract class for data mining\npublic abstract class DataMiner {\n\n    // Template method\n    public final void mine(String path) {\n        openFile(path);\n        extractData();\n        parseData();\n        analyzeData();\n        sendReport();\n        closeFile();\n    }\n\n    // Concrete methods\n    private void openFile(String path) {\n        System.out.println("Opening file: " + path);\n    }\n\n    private void closeFile() {\n        System.out.println("Closing file");\n    }\n\n    // Abstract methods - vary by file type\n    protected abstract void extractData();\n    protected abstract void parseData();\n\n    // Hook method - can be overridden\n    protected void analyzeData() {\n        System.out.println("Performing standard analysis");\n    }\n\n    // Concrete method\n    private void sendReport() {\n        System.out.println("Sending report to management");\n    }\n}\n\n// Concrete implementation for PDF\npublic class PDFDataMiner extends DataMiner {\n\n    @Override\n    protected void extractData() {\n        System.out.println("Extracting data from PDF");\n    }\n\n    @Override\n    protected void parseData() {\n        System.out.println("Parsing PDF data into tables");\n    }\n\n    @Override\n    protected void analyzeData() {\n        System.out.println("Performing PDF-specific analysis");\n    }\n}\n\n// Concrete implementation for CSV\npublic class CSVDataMiner extends DataMiner {\n\n    @Override\n    protected void extractData() {\n        System.out.println("Extracting data from CSV");\n    }\n\n    @Override\n    protected void parseData() {\n        System.out.println("Parsing CSV data");\n    }\n\n    // Uses default analyzeData() hook\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"example-3-game-template",children:"Example 3: Game Template"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public abstract class Game {\n\n    // Template method\n    public final void play() {\n        initialize();\n        startPlay();\n        endPlay();\n        printWinner();\n    }\n\n    // Abstract methods\n    protected abstract void initialize();\n    protected abstract void startPlay();\n    protected abstract void endPlay();\n\n    // Concrete method\n    private void printWinner() {\n        System.out.println("Winner announced!");\n    }\n}\n\npublic class Cricket extends Game {\n\n    @Override\n    protected void initialize() {\n        System.out.println("Cricket Game Initialized");\n    }\n\n    @Override\n    protected void startPlay() {\n        System.out.println("Cricket Game Started");\n    }\n\n    @Override\n    protected void endPlay() {\n        System.out.println("Cricket Game Finished");\n    }\n}\n\npublic class Football extends Game {\n\n    @Override\n    protected void initialize() {\n        System.out.println("Football Game Initialized");\n    }\n\n    @Override\n    protected void startPlay() {\n        System.out.println("Football Game Started");\n    }\n\n    @Override\n    protected void endPlay() {\n        System.out.println("Football Game Finished");\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"hook-methods",children:"Hook Methods"}),"\n",(0,s.jsx)(n.p,{children:"Hooks provide points where subclasses can hook into the algorithm but aren't required to."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public abstract class AbstractClass {\n\n    public final void templateMethod() {\n        step1();\n        step2();\n        if (hook()) {  // Optional behavior\n            step3();\n        }\n        step4();\n    }\n\n    protected abstract void step1();\n    protected abstract void step2();\n    protected abstract void step4();\n\n    // Hook - subclass can override\n    protected boolean hook() {\n        return true; // Default behavior\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Types of Hooks:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Boolean hooks"})," - Control flow (if/else)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Empty hooks"})," - Optional operations (do-nothing default)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Return value hooks"})," - Provide data to algorithm"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"java-api-examples",children:"Java API Examples"}),"\n",(0,s.jsx)(n.h3,{id:"collectionssort",children:"Collections.sort()"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class Person implements Comparable<Person> {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // Template method calls compareTo()\n    @Override\n    public int compareTo(Person other) {\n        return Integer.compare(this.age, other.age);\n    }\n}\n\nList<Person> people = Arrays.asList(\n    new Person("Alice", 30),\n    new Person("Bob", 25)\n);\nCollections.sort(people); // Uses template method\n'})}),"\n",(0,s.jsx)(n.h3,{id:"inputstreamread",children:"InputStream.read()"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public abstract class InputStream {\n    // Template method\n    public int read(byte[] b, int off, int len) throws IOException {\n        // ... validation and loop logic ...\n        for (int i = 0; i < len; i++) {\n            int c = read(); // Calls abstract method\n            if (c == -1) break;\n            b[off + i] = (byte) c;\n        }\n    }\n\n    // Abstract method implemented by subclasses\n    public abstract int read() throws IOException;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"httpservlet",children:"HttpServlet"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public abstract class HttpServlet extends GenericServlet {\n\n    // Template method\n    protected void service(HttpServletRequest req, HttpServletResponse resp) {\n        String method = req.getMethod();\n\n        if (method.equals("GET")) {\n            doGet(req, resp);\n        } else if (method.equals("POST")) {\n            doPost(req, resp);\n        }\n        // ... other methods\n    }\n\n    // Hook methods\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n        // Default implementation\n    }\n\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) {\n        // Default implementation\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"template-method-vs-strategy",children:"Template Method vs Strategy"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Aspect"}),(0,s.jsx)(n.th,{children:"Template Method"}),(0,s.jsx)(n.th,{children:"Strategy"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Intent"})}),(0,s.jsx)(n.td,{children:"Define algorithm skeleton"}),(0,s.jsx)(n.td,{children:"Define family of algorithms"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"When varies"})}),(0,s.jsx)(n.td,{children:"Compile time (inheritance)"}),(0,s.jsx)(n.td,{children:"Runtime (composition)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Flexibility"})}),(0,s.jsx)(n.td,{children:"Less flexible"}),(0,s.jsx)(n.td,{children:"More flexible"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Coupling"})}),(0,s.jsx)(n.td,{children:"Tightly coupled"}),(0,s.jsx)(n.td,{children:"Loosely coupled"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Code reuse"})}),(0,s.jsx)(n.td,{children:"Inherits common code"}),(0,s.jsx)(n.td,{children:"Delegates to strategy"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Use case"})}),(0,s.jsx)(n.td,{children:"Stable algorithm structure"}),(0,s.jsx)(n.td,{children:"Swappable algorithms"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"advantages",children:"Advantages"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Code Reuse"})," - Common algorithm in parent class"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Inversion of Control"})," - Parent calls subclass methods"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Enforces Structure"})," - Algorithm sequence can't be changed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Easy to Extend"})," - Add new variants by subclassing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Single Place"})," - Algorithm logic centralized"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"disadvantages",children:"Disadvantages"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Inheritance Required"})," - Subclasses must inherit"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tight Coupling"})," - Subclasses coupled to parent"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Limited Flexibility"})," - Can't change algorithm structure at runtime"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Liskov Substitution"})," - Subclasses must follow parent contract"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Proliferation"})," - Many subclasses for variations"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Use Template Method Pattern When:"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Multiple classes implement similar algorithms with minor differences"}),"\n",(0,s.jsx)(n.li,{children:"You want to control which parts of algorithm subclasses can change"}),"\n",(0,s.jsx)(n.li,{children:"Common behavior should be in one place"}),"\n",(0,s.jsx)(n.li,{children:"You want to avoid code duplication"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["\u274c ",(0,s.jsx)(n.strong,{children:"Don't Use Template Method Pattern When:"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Algorithm needs to change at runtime (use Strategy)"}),"\n",(0,s.jsx)(n.li,{children:"Variations are too different (no common structure)"}),"\n",(0,s.jsx)(n.li,{children:"You want loose coupling (prefer composition)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-make-template-method-final",children:"1. Make Template Method Final"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public final void templateMethod() {\n    // Prevents subclasses from changing algorithm\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-minimize-abstract-methods",children:"2. Minimize Abstract Methods"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Too many abstract methods\nabstract void step1();\nabstract void step2();\nabstract void step3();\nabstract void step4();\n\n// Better - only vary what's needed\nvoid step1() { /* default */ }\nabstract void step2(); // Only this varies\nvoid step3() { /* default */ }\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-document-hook-points",children:"3. Document Hook Points"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"/**\n * Hook method called before processing.\n * Override to add pre-processing logic.\n * Default implementation does nothing.\n */\nprotected void beforeProcess() {\n    // Default: do nothing\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-use-meaningful-names",children:"4. Use Meaningful Names"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Bad\nprotected abstract void doIt();\n\n// Good\nprotected abstract void extractDataFromSource();\n"})}),"\n",(0,s.jsx)(n.h2,{id:"related-patterns",children:"Related Patterns"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Strategy"})," - Alternative to template method (uses composition)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Factory Method"})," - Often called by template methods"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Command"})," - Can parameterize template method steps"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Defines skeleton of algorithm in base class"}),"\n",(0,s.jsx)(n.li,{children:"Subclasses override specific steps"}),"\n",(0,s.jsx)(n.li,{children:"Template method should be final"}),"\n",(0,s.jsx)(n.li,{children:'Implements "Hollywood Principle"'}),"\n",(0,s.jsx)(n.li,{children:"Hooks provide optional customization points"}),"\n",(0,s.jsx)(n.li,{children:"Common in frameworks (testing, servlets, etc.)"}),"\n",(0,s.jsx)(n.li,{children:"Use when algorithm structure is stable"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"The Template Method Pattern defines the steps of an algorithm and allows subclasses to provide the implementation for one or more steps!"})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);