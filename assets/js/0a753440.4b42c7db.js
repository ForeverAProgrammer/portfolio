"use strict";(globalThis.webpackChunkmy_profile_site=globalThis.webpackChunkmy_profile_site||[]).push([[8807],{28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var a=t(96540);const i={},r=a.createContext(i);function l(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),a.createElement(r.Provider,{value:n},e.children)}},34499:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>l,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"design-patterns/behavioral/strategy","title":"Strategy Pattern","description":"Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.","source":"@site/docs/design-patterns/behavioral/strategy.md","sourceDirName":"design-patterns/behavioral","slug":"/design-patterns/behavioral/strategy","permalink":"/docs/design-patterns/behavioral/strategy","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Behavioral Patterns","permalink":"/docs/design-patterns/behavioral/"},"next":{"title":"Observer Pattern","permalink":"/docs/design-patterns/behavioral/observer"}}');var i=t(74848),r=t(28453);const l={sidebar_position:1},s="Strategy Pattern",c={},o=[{value:"Problem",id:"problem",level:2},{value:"Design Principles Applied",id:"design-principles-applied",level:2},{value:"UML Diagram",id:"uml-diagram",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Step 1: Define the Strategy Interface",id:"step-1-define-the-strategy-interface",level:3},{value:"Step 2: Create Concrete Strategy Classes",id:"step-2-create-concrete-strategy-classes",level:3},{value:"Step 3: Create Context Class",id:"step-3-create-context-class",level:3},{value:"Step 4: Client Code",id:"step-4-client-code",level:3},{value:"Output",id:"output",level:3},{value:"Another Example: Duck Simulator",id:"another-example-duck-simulator",level:2},{value:"Benefits",id:"benefits",level:2},{value:"Drawbacks",id:"drawbacks",level:2},{value:"When to Use",id:"when-to-use",level:2},{value:"Real-World Examples",id:"real-world-examples",level:2},{value:"Java Libraries",id:"java-libraries",level:3},{value:"Layout Managers in Swing",id:"layout-managers-in-swing",level:3},{value:"Related Patterns",id:"related-patterns",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"strategy-pattern",children:"Strategy Pattern"})}),"\n",(0,i.jsx)(n.p,{children:"Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it."}),"\n",(0,i.jsx)(n.h2,{id:"problem",children:"Problem"}),"\n",(0,i.jsx)(n.p,{children:"You need different variations of an algorithm, and you want to be able to switch between them at runtime without using conditional statements."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Common Scenarios:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Different payment methods (credit card, PayPal, cryptocurrency)"}),"\n",(0,i.jsx)(n.li,{children:"Multiple sorting algorithms (quicksort, mergesort, bubblesort)"}),"\n",(0,i.jsx)(n.li,{children:"Various compression strategies (ZIP, RAR, TAR)"}),"\n",(0,i.jsx)(n.li,{children:"Different validation rules based on context"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"design-principles-applied",children:"Design Principles Applied"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Encapsulate what varies"})," - The algorithm implementation varies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Program to an interface, not implementation"})," - Use strategy interface"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Favor composition over inheritance"})," - Compose with strategy objects"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"uml-diagram",children:"UML Diagram"}),"\n",(0,i.jsx)(n.mermaid,{value:"classDiagram\n    class Context {\n        -Strategy strategy\n        +setStrategy(Strategy)\n        +execute()\n    }\n    class Strategy {\n        <<interface>>\n        +algorithm()\n    }\n    class ConcreteStrategyA {\n        +algorithm()\n    }\n    class ConcreteStrategyB {\n        +algorithm()\n    }\n    class ConcreteStrategyC {\n        +algorithm()\n    }\n\n    Context o-- Strategy : strategy\n    Strategy <|.. ConcreteStrategyA : implements\n    Strategy <|.. ConcreteStrategyB : implements\n    Strategy <|.. ConcreteStrategyC : implements"}),"\n",(0,i.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(n.h3,{id:"step-1-define-the-strategy-interface",children:"Step 1: Define the Strategy Interface"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// Strategy interface - defines the contract for all algorithms\npublic interface PaymentStrategy {\n    void pay(double amount);\n    boolean validate();\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-2-create-concrete-strategy-classes",children:"Step 2: Create Concrete Strategy Classes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Concrete Strategy 1: Credit Card Payment\npublic class CreditCardPayment implements PaymentStrategy {\n    private String cardNumber;\n    private String cvv;\n    private String expiryDate;\n\n    public CreditCardPayment(String cardNumber, String cvv, String expiryDate) {\n        this.cardNumber = cardNumber;\n        this.cvv = cvv;\n        this.expiryDate = expiryDate;\n    }\n\n    @Override\n    public boolean validate() {\n        // Validate credit card details\n        System.out.println("Validating credit card: " +\n            cardNumber.substring(cardNumber.length() - 4));\n        return cardNumber.length() == 16 && cvv.length() == 3;\n    }\n\n    @Override\n    public void pay(double amount) {\n        if (validate()) {\n            System.out.println("Paid $" + amount + " using Credit Card");\n            System.out.println("Card ending in: " +\n                cardNumber.substring(cardNumber.length() - 4));\n        } else {\n            System.out.println("Invalid credit card details");\n        }\n    }\n}\n\n// Concrete Strategy 2: PayPal Payment\npublic class PayPalPayment implements PaymentStrategy {\n    private String email;\n    private String password;\n\n    public PayPalPayment(String email, String password) {\n        this.email = email;\n        this.password = password;\n    }\n\n    @Override\n    public boolean validate() {\n        // Validate PayPal credentials\n        System.out.println("Validating PayPal account: " + email);\n        return email.contains("@") && password.length() >= 6;\n    }\n\n    @Override\n    public void pay(double amount) {\n        if (validate()) {\n            System.out.println("Paid $" + amount + " using PayPal");\n            System.out.println("PayPal account: " + email);\n        } else {\n            System.out.println("Invalid PayPal credentials");\n        }\n    }\n}\n\n// Concrete Strategy 3: Cryptocurrency Payment\npublic class CryptoPayment implements PaymentStrategy {\n    private String walletAddress;\n    private String cryptoType;\n\n    public CryptoPayment(String walletAddress, String cryptoType) {\n        this.walletAddress = walletAddress;\n        this.cryptoType = cryptoType;\n    }\n\n    @Override\n    public boolean validate() {\n        // Validate crypto wallet\n        System.out.println("Validating " + cryptoType + " wallet");\n        return walletAddress.length() >= 26;\n    }\n\n    @Override\n    public void pay(double amount) {\n        if (validate()) {\n            System.out.println("Paid $" + amount + " using " + cryptoType);\n            System.out.println("Wallet: " +\n                walletAddress.substring(0, 8) + "...");\n        } else {\n            System.out.println("Invalid crypto wallet");\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"step-3-create-context-class",children:"Step 3: Create Context Class"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Context class that uses a PaymentStrategy\npublic class ShoppingCart {\n    private List<Item> items;\n    private PaymentStrategy paymentStrategy;\n\n    public ShoppingCart() {\n        this.items = new ArrayList<>();\n    }\n\n    public void addItem(Item item) {\n        items.add(item);\n    }\n\n    public void removeItem(Item item) {\n        items.remove(item);\n    }\n\n    public double calculateTotal() {\n        return items.stream()\n                   .mapToDouble(Item::getPrice)\n                   .sum();\n    }\n\n    // Set the payment strategy at runtime\n    public void setPaymentStrategy(PaymentStrategy strategy) {\n        this.paymentStrategy = strategy;\n    }\n\n    // Execute the payment using current strategy\n    public void checkout() {\n        double amount = calculateTotal();\n        if (paymentStrategy == null) {\n            System.out.println("Please select a payment method");\n            return;\n        }\n        paymentStrategy.pay(amount);\n    }\n\n    public void displayItems() {\n        System.out.println("\\nShopping Cart:");\n        items.forEach(item ->\n            System.out.println("- " + item.getName() + ": $" + item.getPrice())\n        );\n        System.out.println("Total: $" + calculateTotal());\n    }\n}\n\n// Simple Item class\nclass Item {\n    private String name;\n    private double price;\n\n    public Item(String name, double price) {\n        this.name = name;\n        this.price = price;\n    }\n\n    public String getName() { return name; }\n    public double getPrice() { return price; }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"step-4-client-code",children:"Step 4: Client Code"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public class StrategyPatternDemo {\n    public static void main(String[] args) {\n        // Create shopping cart\n        ShoppingCart cart = new ShoppingCart();\n\n        // Add items\n        cart.addItem(new Item("Laptop", 999.99));\n        cart.addItem(new Item("Mouse", 29.99));\n        cart.addItem(new Item("Keyboard", 79.99));\n\n        cart.displayItems();\n\n        // Pay with Credit Card\n        System.out.println("\\n=== Paying with Credit Card ===");\n        cart.setPaymentStrategy(\n            new CreditCardPayment("1234567890123456", "123", "12/25")\n        );\n        cart.checkout();\n\n        // Pay with PayPal\n        System.out.println("\\n=== Paying with PayPal ===");\n        cart.setPaymentStrategy(\n            new PayPalPayment("user@example.com", "securepass")\n        );\n        cart.checkout();\n\n        // Pay with Cryptocurrency\n        System.out.println("\\n=== Paying with Bitcoin ===");\n        cart.setPaymentStrategy(\n            new CryptoPayment("1A2B3C4D5E6F7G8H9I0J1K2L3M4N", "Bitcoin")\n        );\n        cart.checkout();\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"output",children:"Output"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Shopping Cart:\n- Laptop: $999.99\n- Mouse: $29.99\n- Keyboard: $79.99\nTotal: $1109.97\n\n=== Paying with Credit Card ===\nValidating credit card: 3456\nPaid $1109.97 using Credit Card\nCard ending in: 3456\n\n=== Paying with PayPal ===\nValidating PayPal account: user@example.com\nPaid $1109.97 using PayPal\nPayPal account: user@example.com\n\n=== Paying with Bitcoin ===\nValidating Bitcoin wallet\nPaid $1109.97 using Bitcoin\nWallet: 1A2B3C4D...\n"})}),"\n",(0,i.jsx)(n.h2,{id:"another-example-duck-simulator",children:"Another Example: Duck Simulator"}),"\n",(0,i.jsx)(n.p,{children:"The classic example from Head First Design Patterns:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Strategy interfaces\npublic interface FlyBehavior {\n    void fly();\n}\n\npublic interface QuackBehavior {\n    void quack();\n}\n\n// Concrete fly behaviors\npublic class FlyWithWings implements FlyBehavior {\n    @Override\n    public void fly() {\n        System.out.println("I\'m flying with wings!");\n    }\n}\n\npublic class FlyNoWay implements FlyBehavior {\n    @Override\n    public void fly() {\n        System.out.println("I can\'t fly");\n    }\n}\n\npublic class FlyRocketPowered implements FlyBehavior {\n    @Override\n    public void fly() {\n        System.out.println("I\'m flying with a rocket!");\n    }\n}\n\n// Concrete quack behaviors\npublic class Quack implements QuackBehavior {\n    @Override\n    public void quack() {\n        System.out.println("Quack quack!");\n    }\n}\n\npublic class Squeak implements QuackBehavior {\n    @Override\n    public void quack() {\n        System.out.println("Squeak!");\n    }\n}\n\npublic class MuteQuack implements QuackBehavior {\n    @Override\n    public void quack() {\n        System.out.println("<< Silence >>");\n    }\n}\n\n// Context class\npublic abstract class Duck {\n    protected FlyBehavior flyBehavior;\n    protected QuackBehavior quackBehavior;\n\n    public Duck() {\n    }\n\n    public void performFly() {\n        flyBehavior.fly();\n    }\n\n    public void performQuack() {\n        quackBehavior.quack();\n    }\n\n    public void swim() {\n        System.out.println("All ducks float, even decoys!");\n    }\n\n    // Allow behavior to be changed at runtime\n    public void setFlyBehavior(FlyBehavior fb) {\n        flyBehavior = fb;\n    }\n\n    public void setQuackBehavior(QuackBehavior qb) {\n        quackBehavior = qb;\n    }\n\n    public abstract void display();\n}\n\n// Concrete Duck types\npublic class MallardDuck extends Duck {\n    public MallardDuck() {\n        flyBehavior = new FlyWithWings();\n        quackBehavior = new Quack();\n    }\n\n    @Override\n    public void display() {\n        System.out.println("I\'m a real Mallard duck");\n    }\n}\n\npublic class ModelDuck extends Duck {\n    public ModelDuck() {\n        flyBehavior = new FlyNoWay();\n        quackBehavior = new Quack();\n    }\n\n    @Override\n    public void display() {\n        System.out.println("I\'m a model duck");\n    }\n}\n\n// Test the duck simulator\npublic class DuckSimulator {\n    public static void main(String[] args) {\n        Duck mallard = new MallardDuck();\n        mallard.display();\n        mallard.performQuack();\n        mallard.performFly();\n\n        System.out.println();\n\n        Duck model = new ModelDuck();\n        model.display();\n        model.performFly();\n\n        // Change behavior at runtime!\n        model.setFlyBehavior(new FlyRocketPowered());\n        model.performFly();\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"benefits",children:"Benefits"}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Eliminates conditional statements"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No need for long if-else or switch statements"}),"\n",(0,i.jsx)(n.li,{children:"Each algorithm is in its own class"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Open/Closed Principle"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Open for extension (add new strategies)"}),"\n",(0,i.jsx)(n.li,{children:"Closed for modification (existing code unchanged)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Runtime flexibility"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Change algorithm/behavior at runtime"}),"\n",(0,i.jsx)(n.li,{children:"Different objects can use different strategies"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Easy testing"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Each strategy can be tested independently"}),"\n",(0,i.jsx)(n.li,{children:"Easy to mock strategies for unit tests"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"drawbacks",children:"Drawbacks"}),"\n",(0,i.jsxs)(n.p,{children:["\u274c ",(0,i.jsx)(n.strong,{children:"Increased number of classes"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Each algorithm becomes a separate class"}),"\n",(0,i.jsx)(n.li,{children:"Can clutter codebase if overused"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u274c ",(0,i.jsx)(n.strong,{children:"Client must be aware of strategies"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Client needs to know about different strategies"}),"\n",(0,i.jsx)(n.li,{children:"Must understand which strategy to use when"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u274c ",(0,i.jsx)(n.strong,{children:"Communication overhead"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Context and strategy may need to exchange data"}),"\n",(0,i.jsx)(n.li,{children:"Strategy interface might need to expose Context"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Use Strategy When:"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You have multiple algorithms for a specific task"}),"\n",(0,i.jsx)(n.li,{children:"You need to switch algorithms at runtime"}),"\n",(0,i.jsx)(n.li,{children:"You want to eliminate conditional statements"}),"\n",(0,i.jsx)(n.li,{children:"Algorithms use different data structures"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u274c ",(0,i.jsx)(n.strong,{children:"Don't Use When:"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You only have one algorithm"}),"\n",(0,i.jsx)(n.li,{children:"Algorithms never change"}),"\n",(0,i.jsx)(n.li,{children:"Simple conditional logic suffices"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,i.jsx)(n.h3,{id:"java-libraries",children:"Java Libraries"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Comparator in Java Collections (Strategy Pattern)\nList<String> names = Arrays.asList("John", "Alice", "Bob");\n\n// Different sorting strategies\nCollections.sort(names, new Comparator<String>() {\n    public int compare(String s1, String s2) {\n        return s1.compareTo(s2); // Alphabetical\n    }\n});\n\nCollections.sort(names, (s1, s2) -> s2.compareTo(s1)); // Reverse\n\nCollections.sort(names, Comparator.comparing(String::length)); // By length\n'})}),"\n",(0,i.jsx)(n.h3,{id:"layout-managers-in-swing",children:"Layout Managers in Swing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// Different layout strategies\nJPanel panel = new JPanel();\npanel.setLayout(new FlowLayout());    // Strategy 1\npanel.setLayout(new BorderLayout());  // Strategy 2\npanel.setLayout(new GridLayout());    // Strategy 3\n"})}),"\n",(0,i.jsx)(n.h2,{id:"related-patterns",children:"Related Patterns"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State Pattern"}),": Similar structure but different intent - State changes behavior based on internal state"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Template Method"}),": Defines algorithm structure in superclass, Strategy uses composition instead of inheritance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Command Pattern"}),": Encapsulates requests, Strategy encapsulates algorithms"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use functional interfaces"})," (Java 8+) for simple strategies"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// Traditional way\npublic interface ValidationStrategy {\n    boolean validate(String input);\n}\n\n// Using functional interface\n@FunctionalInterface\npublic interface ValidationStrategy {\n    boolean validate(String input);\n}\n\n// Usage with lambda\nvalidator.setStrategy(input -> input.length() > 5);\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Provide default strategies"})," in the Context constructor"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"public class ShoppingCart {\n    private PaymentStrategy paymentStrategy = new CreditCardPayment();\n    // ...\n}\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consider using enums"})," for a fixed set of strategies"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"public enum CompressionStrategy {\n    ZIP(new ZipCompression()),\n    RAR(new RarCompression()),\n    TAR(new TarCompression());\n\n    private final Compression compression;\n\n    CompressionStrategy(Compression compression) {\n        this.compression = compression;\n    }\n\n    public void compress(File file) {\n        compression.compress(file);\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"The Strategy Pattern is one of the most useful patterns for:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Replacing conditional logic with polymorphism"}),"\n",(0,i.jsx)(n.li,{children:"Making algorithms interchangeable"}),"\n",(0,i.jsx)(n.li,{children:"Allowing runtime behavior changes"}),"\n",(0,i.jsx)(n.li,{children:"Following the Open/Closed Principle"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Takeaway:"})," Encapsulate what varies (the algorithm) and program to an interface, not an implementation."]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);